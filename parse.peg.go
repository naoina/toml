package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleboolean
	ruleinteger
	ruleanyInt
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"boolean",
	"integer",
	"anyInt",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [94]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.AddKeyValue()
		case ruleAction4:
			p.SetKey(p.buffer, begin, end)
		case ruleAction5:
			p.SetKey(p.buffer, begin, end)
		case ruleAction6:
			p.SetTime(begin, end)
		case ruleAction7:
			p.SetFloat(begin, end)
		case ruleAction8:
			p.SetInteger(begin, end)
		case ruleAction9:
			p.SetString(begin, end)
		case ruleAction10:
			p.SetBool(begin, end)
		case ruleAction11:
			p.SetArray(begin, end)
		case ruleAction12:
			p.SetTable(p.buffer, begin, end)
		case ruleAction13:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction14:
			p.StartInlineTable()
		case ruleAction15:
			p.EndInlineTable()
		case ruleAction16:
			p.AddTableKey()
		case ruleAction17:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction18:
			p.SetMultilineBasicString()
		case ruleAction19:
			p.AddMultilineBasicQuote()
		case ruleAction20:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction21:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction22:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.StartArray()
		case ruleAction24:
			p.AddArrayVal()
		case ruleAction25:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction12, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l38
					}
					position++
					if buffer[position] != rune('\n') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
				}
			l37:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position41 := position
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l45
						}
						position++
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if buffer[position] != rune('\t') {
							goto l43
						}
						position++
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(rulews, position41)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l49
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l49
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l49
							}
						}
					}

					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulewsnl, position47)
			}
			return true
		},
		/* 5 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if buffer[position] != rune('#') {
					goto l51
				}
				position++
				{
					position53 := position
				l54:
					{
						position55, tokenIndex55 := position, tokenIndex
						{
							position56, tokenIndex56 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l57
							}
							position++
							goto l56
						l57:
							position, tokenIndex = position56, tokenIndex56
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l55
							}
							position++
						}
					l56:
						goto l54
					l55:
						position, tokenIndex = position55, tokenIndex55
					}
					add(rulePegText, position53)
				}
				add(rulecomment, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 6 keyval <- <(key ws '=' ws val Action3)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				if !_rules[rulekey]() {
					goto l58
				}
				if !_rules[rulews]() {
					goto l58
				}
				if buffer[position] != rune('=') {
					goto l58
				}
				position++
				if !_rules[rulews]() {
					goto l58
				}
				if !_rules[ruleval]() {
					goto l58
				}
				{
					add(ruleAction3, position)
				}
				add(rulekeyval, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 7 key <- <(bareKey / quotedKey)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				{
					position63, tokenIndex63 := position, tokenIndex
					{
						position65 := position
						{
							position66 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l64
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l64
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l64
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l64
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l64
									}
									position++
								}
							}

						l67:
							{
								position68, tokenIndex68 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l68
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l68
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l68
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l68
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l68
										}
										position++
									}
								}

								goto l67
							l68:
								position, tokenIndex = position68, tokenIndex68
							}
							add(rulePegText, position66)
						}
						{
							add(ruleAction4, position)
						}
						add(rulebareKey, position65)
					}
					goto l63
				l64:
					position, tokenIndex = position63, tokenIndex63
					{
						position72 := position
						{
							position73 := position
							if buffer[position] != rune('"') {
								goto l61
							}
							position++
						l74:
							{
								position75, tokenIndex75 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l75
								}
								goto l74
							l75:
								position, tokenIndex = position75, tokenIndex75
							}
							if buffer[position] != rune('"') {
								goto l61
							}
							position++
							add(rulePegText, position73)
						}
						{
							add(ruleAction5, position)
						}
						add(rulequotedKey, position72)
					}
				}
			l63:
				add(rulekey, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 8 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action4)> */
		nil,
		/* 9 quotedKey <- <(<('"' basicChar* '"')> Action5)> */
		nil,
		/* 10 val <- <((<datetime> Action6) / (<float> Action7) / ((&('{') inlineTable) | (&('[') (<array> Action11)) | (&('f' | 't') (<boolean> Action10)) | (&('"' | '\'') (<string> Action9)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action8))))> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					{
						position83 := position
						{
							position84 := position
							{
								position85, tokenIndex85 := position, tokenIndex
								{
									position87 := position
									{
										position88 := position
										{
											position89 := position
											if !_rules[ruledigitDual]() {
												goto l86
											}
											if !_rules[ruledigitDual]() {
												goto l86
											}
											add(ruledigitQuad, position89)
										}
										add(ruledateFullYear, position88)
									}
									if buffer[position] != rune('-') {
										goto l86
									}
									position++
									{
										position90 := position
										if !_rules[ruledigitDual]() {
											goto l86
										}
										add(ruledateMonth, position90)
									}
									if buffer[position] != rune('-') {
										goto l86
									}
									position++
									{
										position91 := position
										if !_rules[ruledigitDual]() {
											goto l86
										}
										add(ruledateMDay, position91)
									}
									add(rulefullDate, position87)
								}
								{
									position92, tokenIndex92 := position, tokenIndex
									{
										position94, tokenIndex94 := position, tokenIndex
										if buffer[position] != rune('T') {
											goto l95
										}
										position++
										goto l94
									l95:
										position, tokenIndex = position94, tokenIndex94
										if buffer[position] != rune(' ') {
											goto l92
										}
										position++
									}
								l94:
									{
										position96 := position
										if !_rules[rulepartialTime]() {
											goto l92
										}
										{
											position97, tokenIndex97 := position, tokenIndex
											{
												position99 := position
												{
													position100, tokenIndex100 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l101
													}
													position++
													goto l100
												l101:
													position, tokenIndex = position100, tokenIndex100
													{
														position102 := position
														{
															position103, tokenIndex103 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l104
															}
															position++
															goto l103
														l104:
															position, tokenIndex = position103, tokenIndex103
															if buffer[position] != rune('+') {
																goto l97
															}
															position++
														}
													l103:
														if !_rules[ruletimeHour]() {
															goto l97
														}
														if buffer[position] != rune(':') {
															goto l97
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l97
														}
														add(ruletimeNumoffset, position102)
													}
												}
											l100:
												add(ruletimeOffset, position99)
											}
											goto l98
										l97:
											position, tokenIndex = position97, tokenIndex97
										}
									l98:
										add(rulefullTime, position96)
									}
									goto l93
								l92:
									position, tokenIndex = position92, tokenIndex92
								}
							l93:
								goto l85
							l86:
								position, tokenIndex = position85, tokenIndex85
								if !_rules[rulepartialTime]() {
									goto l82
								}
							}
						l85:
							add(ruledatetime, position84)
						}
						add(rulePegText, position83)
					}
					{
						add(ruleAction6, position)
					}
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					{
						position107 := position
						{
							position108 := position
							{
								position109, tokenIndex109 := position, tokenIndex
								{
									position111, tokenIndex111 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l112
									}
									position++
									goto l111
								l112:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('-') {
										goto l109
									}
									position++
								}
							l111:
								goto l110
							l109:
								position, tokenIndex = position109, tokenIndex109
							}
						l110:
							if !_rules[ruledecimalInt]() {
								goto l106
							}
							{
								position113, tokenIndex113 := position, tokenIndex
								if !_rules[rulefloatFrac]() {
									goto l114
								}
								{
									position115, tokenIndex115 := position, tokenIndex
									if !_rules[rulefloatExp]() {
										goto l115
									}
									goto l116
								l115:
									position, tokenIndex = position115, tokenIndex115
								}
							l116:
								goto l113
							l114:
								position, tokenIndex = position113, tokenIndex113
								{
									position117, tokenIndex117 := position, tokenIndex
									if !_rules[rulefloatFrac]() {
										goto l117
									}
									goto l118
								l117:
									position, tokenIndex = position117, tokenIndex117
								}
							l118:
								if !_rules[rulefloatExp]() {
									goto l106
								}
							}
						l113:
							add(rulefloat, position108)
						}
						add(rulePegText, position107)
					}
					{
						add(ruleAction7, position)
					}
					goto l81
				l106:
					position, tokenIndex = position81, tokenIndex81
					{
						switch buffer[position] {
						case '{':
							{
								position121 := position
								if buffer[position] != rune('{') {
									goto l79
								}
								position++
								{
									add(ruleAction14, position)
								}
								if !_rules[rulews]() {
									goto l79
								}
								{
									position123 := position
								l124:
									{
										position125, tokenIndex125 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l125
										}
										{
											position126, tokenIndex126 := position, tokenIndex
											{
												position128 := position
												if !_rules[rulews]() {
													goto l126
												}
												if buffer[position] != rune(',') {
													goto l126
												}
												position++
												if !_rules[rulews]() {
													goto l126
												}
												add(ruleinlineTableValSep, position128)
											}
											goto l127
										l126:
											position, tokenIndex = position126, tokenIndex126
										}
									l127:
										goto l124
									l125:
										position, tokenIndex = position125, tokenIndex125
									}
									add(ruleinlineTableKeyValues, position123)
								}
								if !_rules[rulews]() {
									goto l79
								}
								if buffer[position] != rune('}') {
									goto l79
								}
								position++
								{
									add(ruleAction15, position)
								}
								add(ruleinlineTable, position121)
							}
						case '[':
							{
								position130 := position
								{
									position131 := position
									if buffer[position] != rune('[') {
										goto l79
									}
									position++
									{
										add(ruleAction23, position)
									}
									if !_rules[rulewsnl]() {
										goto l79
									}
									{
										position133, tokenIndex133 := position, tokenIndex
										{
											position135 := position
											if !_rules[ruleval]() {
												goto l133
											}
											{
												add(ruleAction24, position)
											}
										l137:
											{
												position138, tokenIndex138 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l138
												}
												{
													position139, tokenIndex139 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l139
													}
													goto l140
												l139:
													position, tokenIndex = position139, tokenIndex139
												}
											l140:
												if !_rules[rulewsnl]() {
													goto l138
												}
												if !_rules[rulearraySep]() {
													goto l138
												}
												if !_rules[rulewsnl]() {
													goto l138
												}
												{
													position141, tokenIndex141 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l141
													}
													goto l142
												l141:
													position, tokenIndex = position141, tokenIndex141
												}
											l142:
												if !_rules[rulewsnl]() {
													goto l138
												}
												if !_rules[ruleval]() {
													goto l138
												}
												{
													add(ruleAction25, position)
												}
												goto l137
											l138:
												position, tokenIndex = position138, tokenIndex138
											}
											if !_rules[rulewsnl]() {
												goto l133
											}
											{
												position144, tokenIndex144 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l144
												}
												goto l145
											l144:
												position, tokenIndex = position144, tokenIndex144
											}
										l145:
											if !_rules[rulewsnl]() {
												goto l133
											}
											{
												position146, tokenIndex146 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l146
												}
												goto l147
											l146:
												position, tokenIndex = position146, tokenIndex146
											}
										l147:
											add(rulearrayValues, position135)
										}
										goto l134
									l133:
										position, tokenIndex = position133, tokenIndex133
									}
								l134:
									if !_rules[rulewsnl]() {
										goto l79
									}
									if buffer[position] != rune(']') {
										goto l79
									}
									position++
									add(rulearray, position131)
								}
								add(rulePegText, position130)
							}
							{
								add(ruleAction11, position)
							}
						case 'f', 't':
							{
								position149 := position
								{
									position150 := position
									{
										position151, tokenIndex151 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l152
										}
										position++
										if buffer[position] != rune('r') {
											goto l152
										}
										position++
										if buffer[position] != rune('u') {
											goto l152
										}
										position++
										if buffer[position] != rune('e') {
											goto l152
										}
										position++
										goto l151
									l152:
										position, tokenIndex = position151, tokenIndex151
										if buffer[position] != rune('f') {
											goto l79
										}
										position++
										if buffer[position] != rune('a') {
											goto l79
										}
										position++
										if buffer[position] != rune('l') {
											goto l79
										}
										position++
										if buffer[position] != rune('s') {
											goto l79
										}
										position++
										if buffer[position] != rune('e') {
											goto l79
										}
										position++
									}
								l151:
									add(ruleboolean, position150)
								}
								add(rulePegText, position149)
							}
							{
								add(ruleAction10, position)
							}
						case '"', '\'':
							{
								position154 := position
								{
									position155 := position
									{
										position156, tokenIndex156 := position, tokenIndex
										{
											position158 := position
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											{
												position159 := position
												{
													position160 := position
												l161:
													{
														position162, tokenIndex162 := position, tokenIndex
														{
															position163, tokenIndex163 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l163
															}
															position++
															if buffer[position] != rune('\'') {
																goto l163
															}
															position++
															if buffer[position] != rune('\'') {
																goto l163
															}
															position++
															goto l162
														l163:
															position, tokenIndex = position163, tokenIndex163
														}
														{
															position164, tokenIndex164 := position, tokenIndex
															{
																position166 := position
																{
																	position167, tokenIndex167 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l168
																	}
																	position++
																	goto l167
																l168:
																	position, tokenIndex = position167, tokenIndex167
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l165
																	}
																	position++
																}
															l167:
																add(rulemlLiteralChar, position166)
															}
															goto l164
														l165:
															position, tokenIndex = position164, tokenIndex164
															if !_rules[rulenewline]() {
																goto l162
															}
														}
													l164:
														goto l161
													l162:
														position, tokenIndex = position162, tokenIndex162
													}
													add(rulemlLiteralBody, position160)
												}
												add(rulePegText, position159)
											}
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											if buffer[position] != rune('\'') {
												goto l157
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(rulemlLiteralString, position158)
										}
										goto l156
									l157:
										position, tokenIndex = position156, tokenIndex156
										{
											position171 := position
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											{
												position172 := position
											l173:
												{
													position174, tokenIndex174 := position, tokenIndex
													{
														position175 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l174
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l174
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l174
																}
																position++
															}
														}

														add(ruleliteralChar, position175)
													}
													goto l173
												l174:
													position, tokenIndex = position174, tokenIndex174
												}
												add(rulePegText, position172)
											}
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											{
												add(ruleAction21, position)
											}
											add(ruleliteralString, position171)
										}
										goto l156
									l170:
										position, tokenIndex = position156, tokenIndex156
										{
											position179 := position
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											{
												position180 := position
											l181:
												{
													position182, tokenIndex182 := position, tokenIndex
													{
														position183, tokenIndex183 := position, tokenIndex
														{
															position185, tokenIndex185 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l185
															}
															position++
															if buffer[position] != rune('"') {
																goto l185
															}
															position++
															if buffer[position] != rune('"') {
																goto l185
															}
															position++
															goto l184
														l185:
															position, tokenIndex = position185, tokenIndex185
														}
														if buffer[position] != rune('"') {
															goto l184
														}
														position++
														{
															add(ruleAction19, position)
														}
														goto l183
													l184:
														position, tokenIndex = position183, tokenIndex183
														{
															position188 := position
															{
																position189, tokenIndex189 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l190
																}
																goto l189
															l190:
																position, tokenIndex = position189, tokenIndex189
																if !_rules[rulenewline]() {
																	goto l187
																}
															}
														l189:
															add(rulePegText, position188)
														}
														{
															add(ruleAction20, position)
														}
														goto l183
													l187:
														position, tokenIndex = position183, tokenIndex183
														if !_rules[ruleescape]() {
															goto l182
														}
														if !_rules[rulenewline]() {
															goto l182
														}
														if !_rules[rulewsnl]() {
															goto l182
														}
													}
												l183:
													goto l181
												l182:
													position, tokenIndex = position182, tokenIndex182
												}
												add(rulemlBasicBody, position180)
											}
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											if buffer[position] != rune('"') {
												goto l178
											}
											position++
											{
												add(ruleAction18, position)
											}
											add(rulemlBasicString, position179)
										}
										goto l156
									l178:
										position, tokenIndex = position156, tokenIndex156
										{
											position193 := position
											{
												position194 := position
												if buffer[position] != rune('"') {
													goto l79
												}
												position++
											l195:
												{
													position196, tokenIndex196 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l196
													}
													goto l195
												l196:
													position, tokenIndex = position196, tokenIndex196
												}
												if buffer[position] != rune('"') {
													goto l79
												}
												position++
												add(rulePegText, position194)
											}
											{
												add(ruleAction17, position)
											}
											add(rulebasicString, position193)
										}
									}
								l156:
									add(rulestring, position155)
								}
								add(rulePegText, position154)
							}
							{
								add(ruleAction9, position)
							}
						default:
							{
								position199 := position
								{
									position200 := position
									{
										switch buffer[position] {
										case '-':
											if buffer[position] != rune('-') {
												goto l79
											}
											position++
											if !_rules[ruleanyInt]() {
												goto l79
											}
										case '+':
											if buffer[position] != rune('+') {
												goto l79
											}
											position++
											if !_rules[ruledecimalInt]() {
												goto l79
											}
										default:
											if !_rules[ruleanyInt]() {
												goto l79
											}
										}
									}

									add(ruleinteger, position200)
								}
								add(rulePegText, position199)
							}
							{
								add(ruleAction8, position)
							}
						}
					}

				}
			l81:
				add(ruleval, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 11 table <- <(stdTable / arrayTable)> */
		nil,
		/* 12 stdTable <- <('[' ws <tableKey> ws ']' Action12)> */
		nil,
		/* 13 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action13)> */
		nil,
		/* 14 inlineTable <- <('{' Action14 ws inlineTableKeyValues ws '}' Action15)> */
		nil,
		/* 15 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				if !_rules[ruletableKeyComp]() {
					goto l208
				}
			l210:
				{
					position211, tokenIndex211 := position, tokenIndex
					{
						position212 := position
						if !_rules[rulews]() {
							goto l211
						}
						if buffer[position] != rune('.') {
							goto l211
						}
						position++
						if !_rules[rulews]() {
							goto l211
						}
						add(ruletableKeySep, position212)
					}
					if !_rules[ruletableKeyComp]() {
						goto l211
					}
					goto l210
				l211:
					position, tokenIndex = position211, tokenIndex211
				}
				add(ruletableKey, position209)
			}
			return true
		l208:
			position, tokenIndex = position208, tokenIndex208
			return false
		},
		/* 17 tableKeyComp <- <(key Action16)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if !_rules[rulekey]() {
					goto l213
				}
				{
					add(ruleAction16, position)
				}
				add(ruletableKeyComp, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 21 integer <- <((&('-') ('-' anyInt)) | (&('+') ('+' decimalInt)) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') anyInt))> */
		nil,
		/* 22 anyInt <- <(hexInt / octalInt / binaryInt / decimalInt)> */
		func() bool {
			position220, tokenIndex220 := position, tokenIndex
			{
				position221 := position
				{
					position222, tokenIndex222 := position, tokenIndex
					{
						position224 := position
						if buffer[position] != rune('0') {
							goto l223
						}
						position++
						if buffer[position] != rune('x') {
							goto l223
						}
						position++
						if !_rules[rulehexDigit]() {
							goto l223
						}
					l225:
						{
							position226, tokenIndex226 := position, tokenIndex
							{
								position227, tokenIndex227 := position, tokenIndex
								if !_rules[rulehexDigit]() {
									goto l228
								}
								goto l227
							l228:
								position, tokenIndex = position227, tokenIndex227
								if buffer[position] != rune('_') {
									goto l226
								}
								position++
								if !_rules[rulehexDigit]() {
									goto l226
								}
							}
						l227:
							goto l225
						l226:
							position, tokenIndex = position226, tokenIndex226
						}
						add(rulehexInt, position224)
					}
					goto l222
				l223:
					position, tokenIndex = position222, tokenIndex222
					{
						position230 := position
						if buffer[position] != rune('0') {
							goto l229
						}
						position++
						if buffer[position] != rune('o') {
							goto l229
						}
						position++
						if !_rules[ruleoctalDigit]() {
							goto l229
						}
					l231:
						{
							position232, tokenIndex232 := position, tokenIndex
							{
								position233, tokenIndex233 := position, tokenIndex
								if !_rules[ruleoctalDigit]() {
									goto l234
								}
								goto l233
							l234:
								position, tokenIndex = position233, tokenIndex233
								if buffer[position] != rune('_') {
									goto l232
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l232
								}
							}
						l233:
							goto l231
						l232:
							position, tokenIndex = position232, tokenIndex232
						}
						add(ruleoctalInt, position230)
					}
					goto l222
				l229:
					position, tokenIndex = position222, tokenIndex222
					{
						position236 := position
						if buffer[position] != rune('0') {
							goto l235
						}
						position++
						if buffer[position] != rune('b') {
							goto l235
						}
						position++
						if !_rules[rulebinaryDigit]() {
							goto l235
						}
					l237:
						{
							position238, tokenIndex238 := position, tokenIndex
							{
								position239, tokenIndex239 := position, tokenIndex
								if !_rules[rulebinaryDigit]() {
									goto l240
								}
								goto l239
							l240:
								position, tokenIndex = position239, tokenIndex239
								if buffer[position] != rune('_') {
									goto l238
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l238
								}
							}
						l239:
							goto l237
						l238:
							position, tokenIndex = position238, tokenIndex238
						}
						add(rulebinaryInt, position236)
					}
					goto l222
				l235:
					position, tokenIndex = position222, tokenIndex222
					if !_rules[ruledecimalInt]() {
						goto l220
					}
				}
			l222:
				add(ruleanyInt, position221)
			}
			return true
		l220:
			position, tokenIndex = position220, tokenIndex220
			return false
		},
		/* 23 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position241, tokenIndex241 := position, tokenIndex
			{
				position242 := position
				{
					position243, tokenIndex243 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l244
					}
					position++
					{
						position247, tokenIndex247 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l248
						}
						goto l247
					l248:
						position, tokenIndex = position247, tokenIndex247
						if buffer[position] != rune('_') {
							goto l244
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l244
						}
					}
				l247:
				l245:
					{
						position246, tokenIndex246 := position, tokenIndex
						{
							position249, tokenIndex249 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l250
							}
							goto l249
						l250:
							position, tokenIndex = position249, tokenIndex249
							if buffer[position] != rune('_') {
								goto l246
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l246
							}
						}
					l249:
						goto l245
					l246:
						position, tokenIndex = position246, tokenIndex246
					}
					goto l243
				l244:
					position, tokenIndex = position243, tokenIndex243
					if !_rules[ruledecimalDigit]() {
						goto l241
					}
				}
			l243:
				add(ruledecimalInt, position242)
			}
			return true
		l241:
			position, tokenIndex = position241, tokenIndex241
			return false
		},
		/* 24 decimalDigit <- <[0-9]> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l251
				}
				position++
				add(ruledecimalDigit, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 25 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 26 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l254
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l254
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l254
						}
						position++
					}
				}

				add(rulehexDigit, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 27 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 28 octalDigit <- <[0-7]> */
		func() bool {
			position258, tokenIndex258 := position, tokenIndex
			{
				position259 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l258
				}
				position++
				add(ruleoctalDigit, position259)
			}
			return true
		l258:
			position, tokenIndex = position258, tokenIndex258
			return false
		},
		/* 29 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 30 binaryDigit <- <('0' / '1')> */
		func() bool {
			position261, tokenIndex261 := position, tokenIndex
			{
				position262 := position
				{
					position263, tokenIndex263 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l264
					}
					position++
					goto l263
				l264:
					position, tokenIndex = position263, tokenIndex263
					if buffer[position] != rune('1') {
						goto l261
					}
					position++
				}
			l263:
				add(rulebinaryDigit, position262)
			}
			return true
		l261:
			position, tokenIndex = position261, tokenIndex261
			return false
		},
		/* 31 float <- <(('+' / '-')? decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 32 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position266, tokenIndex266 := position, tokenIndex
			{
				position267 := position
				if buffer[position] != rune('.') {
					goto l266
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l266
				}
			l268:
				{
					position269, tokenIndex269 := position, tokenIndex
					{
						position270, tokenIndex270 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l271
						}
						goto l270
					l271:
						position, tokenIndex = position270, tokenIndex270
						if buffer[position] != rune('_') {
							goto l269
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l269
						}
					}
				l270:
					goto l268
				l269:
					position, tokenIndex = position269, tokenIndex269
				}
				add(rulefloatFrac, position267)
			}
			return true
		l266:
			position, tokenIndex = position266, tokenIndex266
			return false
		},
		/* 33 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				{
					position274, tokenIndex274 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l275
					}
					position++
					goto l274
				l275:
					position, tokenIndex = position274, tokenIndex274
					if buffer[position] != rune('E') {
						goto l272
					}
					position++
				}
			l274:
				{
					position276, tokenIndex276 := position, tokenIndex
					{
						position278, tokenIndex278 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('+') {
							goto l276
						}
						position++
					}
				l278:
					goto l277
				l276:
					position, tokenIndex = position276, tokenIndex276
				}
			l277:
				if !_rules[ruledecimalDigit]() {
					goto l272
				}
			l280:
				{
					position281, tokenIndex281 := position, tokenIndex
					{
						position282, tokenIndex282 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l283
						}
						goto l282
					l283:
						position, tokenIndex = position282, tokenIndex282
						if buffer[position] != rune('_') {
							goto l281
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l281
						}
					}
				l282:
					goto l280
				l281:
					position, tokenIndex = position281, tokenIndex281
				}
				add(rulefloatExp, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 34 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 35 escape <- <'\\'> */
		func() bool {
			position285, tokenIndex285 := position, tokenIndex
			{
				position286 := position
				if buffer[position] != rune('\\') {
					goto l285
				}
				position++
				add(ruleescape, position286)
			}
			return true
		l285:
			position, tokenIndex = position285, tokenIndex285
			return false
		},
		/* 36 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if !_rules[rulehexDigit]() {
					goto l287
				}
				if !_rules[rulehexDigit]() {
					goto l287
				}
				if !_rules[rulehexDigit]() {
					goto l287
				}
				if !_rules[rulehexDigit]() {
					goto l287
				}
				add(rulehexQuad, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 37 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 38 basicString <- <(<('"' basicChar* '"')> Action17)> */
		nil,
		/* 39 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				{
					position293, tokenIndex293 := position, tokenIndex
					{
						position295 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l294
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l294
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l294
								}
								position++
							}
						}

						add(rulebasicUnescaped, position295)
					}
					goto l293
				l294:
					position, tokenIndex = position293, tokenIndex293
					{
						position297 := position
						if !_rules[ruleescape]() {
							goto l291
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l291
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l291
								}
								if !_rules[rulehexQuad]() {
									goto l291
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l291
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l291
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l291
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l291
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l291
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l291
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l291
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l291
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l291
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l291
								}
								position++
							}
						}

						add(ruleescaped, position297)
					}
				}
			l293:
				add(rulebasicChar, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 40 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') []-\U0010ffff]))> */
		nil,
		/* 41 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action18)> */
		nil,
		/* 42 mlBasicBody <- <((!('"' '"' '"') '"' Action19) / (<(basicChar / newline)> Action20) / (escape newline wsnl))*> */
		nil,
		/* 43 literalString <- <('\'' <literalChar*> '\'' Action21)> */
		nil,
		/* 44 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') [(-\U0010ffff]))> */
		nil,
		/* 45 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action22)> */
		nil,
		/* 46 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 47 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 48 dateFullYear <- <digitQuad> */
		nil,
		/* 49 dateMonth <- <digitDual> */
		nil,
		/* 50 dateMDay <- <digitDual> */
		nil,
		/* 51 timeHour <- <digitDual> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if !_rules[ruledigitDual]() {
					goto l310
				}
				add(ruletimeHour, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 52 timeMinute <- <digitDual> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if !_rules[ruledigitDual]() {
					goto l312
				}
				add(ruletimeMinute, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 53 timeSecond <- <digitDual> */
		nil,
		/* 54 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 55 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 56 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 57 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if !_rules[ruletimeHour]() {
					goto l318
				}
				if buffer[position] != rune(':') {
					goto l318
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l318
				}
				if buffer[position] != rune(':') {
					goto l318
				}
				position++
				{
					position320 := position
					if !_rules[ruledigitDual]() {
						goto l318
					}
					add(ruletimeSecond, position320)
				}
				{
					position321, tokenIndex321 := position, tokenIndex
					{
						position323 := position
						if buffer[position] != rune('.') {
							goto l321
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l321
						}
					l324:
						{
							position325, tokenIndex325 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l325
							}
							goto l324
						l325:
							position, tokenIndex = position325, tokenIndex325
						}
						add(ruletimeSecfrac, position323)
					}
					goto l322
				l321:
					position, tokenIndex = position321, tokenIndex321
				}
			l322:
				add(rulepartialTime, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 58 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 59 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 60 datetime <- <((fullDate (('T' / ' ') fullTime)?) / partialTime)> */
		nil,
		/* 61 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position329, tokenIndex329 := position, tokenIndex
			{
				position330 := position
				if !_rules[ruledecimalDigit]() {
					goto l329
				}
				if !_rules[ruledecimalDigit]() {
					goto l329
				}
				add(ruledigitDual, position330)
			}
			return true
		l329:
			position, tokenIndex = position329, tokenIndex329
			return false
		},
		/* 62 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 63 array <- <('[' Action23 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 64 arrayValues <- <(val Action24 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action25)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 65 arraySep <- <','> */
		func() bool {
			position334, tokenIndex334 := position, tokenIndex
			{
				position335 := position
				if buffer[position] != rune(',') {
					goto l334
				}
				position++
				add(rulearraySep, position335)
			}
			return true
		l334:
			position, tokenIndex = position334, tokenIndex334
			return false
		},
		/* 67 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 69 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 70 Action2 <- <{ p.Newline() }> */
		nil,
		/* 71 Action3 <- <{ p.AddKeyValue() }> */
		nil,
		/* 72 Action4 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 73 Action5 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 74 Action6 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 75 Action7 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 76 Action8 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 77 Action9 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 78 Action10 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 79 Action11 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 80 Action12 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 81 Action13 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 82 Action14 <- <{ p.StartInlineTable() }> */
		nil,
		/* 83 Action15 <- <{ p.EndInlineTable() }> */
		nil,
		/* 84 Action16 <- <{ p.AddTableKey() }> */
		nil,
		/* 85 Action17 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 86 Action18 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 87 Action19 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 88 Action20 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 89 Action21 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 90 Action22 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 91 Action23 <- <{ p.StartArray() }> */
		nil,
		/* 92 Action24 <- <{ p.AddArrayVal() }> */
		nil,
		/* 93 Action25 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
