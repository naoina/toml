package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleboolean
	ruleinteger
	ruleanyInt
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"boolean",
	"integer",
	"anyInt",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [95]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.SetTime(begin, end)
		case ruleAction4:
			p.SetFloat(begin, end)
		case ruleAction5:
			p.SetInteger(begin, end)
		case ruleAction6:
			p.SetString(begin, end)
		case ruleAction7:
			p.SetBool(begin, end)
		case ruleAction8:
			p.SetArray(begin, end)
		case ruleAction9:
			p.SetTable(p.buffer, begin, end)
		case ruleAction10:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction11:
			p.StartInlineTable()
		case ruleAction12:
			p.EndInlineTable()
		case ruleAction13:
			p.AddKeyValue()
		case ruleAction14:
			p.SetKey(p.buffer, begin, end)
		case ruleAction15:
			p.SetKey(p.buffer, begin, end)
		case ruleAction16:
			p.AddTableKey()
		case ruleAction17:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction18:
			p.SetMultilineBasicString()
		case ruleAction19:
			p.AddMultilineBasicQuote()
		case ruleAction20:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction21:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction22:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.StartArray()
		case ruleAction24:
			p.AddArrayVal()
		case ruleAction25:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction9, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction10, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l38
					}
					position++
					if buffer[position] != rune('\n') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
				}
			l37:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position41 := position
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l45
						}
						position++
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if buffer[position] != rune('\t') {
							goto l43
						}
						position++
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(rulews, position41)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l49
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l49
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l49
							}
						}
					}

					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulewsnl, position47)
			}
			return true
		},
		/* 5 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if buffer[position] != rune('#') {
					goto l51
				}
				position++
				{
					position53 := position
				l54:
					{
						position55, tokenIndex55 := position, tokenIndex
						{
							position56, tokenIndex56 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l57
							}
							position++
							goto l56
						l57:
							position, tokenIndex = position56, tokenIndex56
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l55
							}
							position++
						}
					l56:
						goto l54
					l55:
						position, tokenIndex = position55, tokenIndex55
					}
					add(rulePegText, position53)
				}
				add(rulecomment, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 6 val <- <((<datetime> Action3) / (<float> Action4) / ((&('{') inlineTable) | (&('[') (<array> Action8)) | (&('f' | 't') (<boolean> Action7)) | (&('"' | '\'') (<string> Action6)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action5))))> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				{
					position60, tokenIndex60 := position, tokenIndex
					{
						position62 := position
						{
							position63 := position
							{
								position64, tokenIndex64 := position, tokenIndex
								{
									position66 := position
									{
										position67 := position
										{
											position68 := position
											if !_rules[ruledigitDual]() {
												goto l65
											}
											if !_rules[ruledigitDual]() {
												goto l65
											}
											add(ruledigitQuad, position68)
										}
										add(ruledateFullYear, position67)
									}
									if buffer[position] != rune('-') {
										goto l65
									}
									position++
									{
										position69 := position
										if !_rules[ruledigitDual]() {
											goto l65
										}
										add(ruledateMonth, position69)
									}
									if buffer[position] != rune('-') {
										goto l65
									}
									position++
									{
										position70 := position
										if !_rules[ruledigitDual]() {
											goto l65
										}
										add(ruledateMDay, position70)
									}
									add(rulefullDate, position66)
								}
								{
									position71, tokenIndex71 := position, tokenIndex
									{
										position73, tokenIndex73 := position, tokenIndex
										if buffer[position] != rune('T') {
											goto l74
										}
										position++
										goto l73
									l74:
										position, tokenIndex = position73, tokenIndex73
										if buffer[position] != rune(' ') {
											goto l71
										}
										position++
									}
								l73:
									{
										position75 := position
										if !_rules[rulepartialTime]() {
											goto l71
										}
										{
											position76, tokenIndex76 := position, tokenIndex
											{
												position78 := position
												{
													position79, tokenIndex79 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l80
													}
													position++
													goto l79
												l80:
													position, tokenIndex = position79, tokenIndex79
													{
														position81 := position
														{
															position82, tokenIndex82 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l83
															}
															position++
															goto l82
														l83:
															position, tokenIndex = position82, tokenIndex82
															if buffer[position] != rune('+') {
																goto l76
															}
															position++
														}
													l82:
														if !_rules[ruletimeHour]() {
															goto l76
														}
														if buffer[position] != rune(':') {
															goto l76
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l76
														}
														add(ruletimeNumoffset, position81)
													}
												}
											l79:
												add(ruletimeOffset, position78)
											}
											goto l77
										l76:
											position, tokenIndex = position76, tokenIndex76
										}
									l77:
										add(rulefullTime, position75)
									}
									goto l72
								l71:
									position, tokenIndex = position71, tokenIndex71
								}
							l72:
								goto l64
							l65:
								position, tokenIndex = position64, tokenIndex64
								if !_rules[rulepartialTime]() {
									goto l61
								}
							}
						l64:
							add(ruledatetime, position63)
						}
						add(rulePegText, position62)
					}
					{
						add(ruleAction3, position)
					}
					goto l60
				l61:
					position, tokenIndex = position60, tokenIndex60
					{
						position86 := position
						{
							position87 := position
							{
								position88, tokenIndex88 := position, tokenIndex
								{
									position90, tokenIndex90 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l91
									}
									position++
									goto l90
								l91:
									position, tokenIndex = position90, tokenIndex90
									if buffer[position] != rune('-') {
										goto l88
									}
									position++
								}
							l90:
								goto l89
							l88:
								position, tokenIndex = position88, tokenIndex88
							}
						l89:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l85
									}
									position++
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
									if buffer[position] != rune('f') {
										goto l85
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
									if buffer[position] != rune('a') {
										goto l85
									}
									position++
									if buffer[position] != rune('n') {
										goto l85
									}
									position++
								default:
									{
										position93 := position
										if !_rules[ruledecimalInt]() {
											goto l85
										}
										{
											position94, tokenIndex94 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l95
											}
											{
												position96, tokenIndex96 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l96
												}
												goto l97
											l96:
												position, tokenIndex = position96, tokenIndex96
											}
										l97:
											goto l94
										l95:
											position, tokenIndex = position94, tokenIndex94
											{
												position98, tokenIndex98 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l98
												}
												goto l99
											l98:
												position, tokenIndex = position98, tokenIndex98
											}
										l99:
											if !_rules[rulefloatExp]() {
												goto l85
											}
										}
									l94:
										add(rulefloatDigits, position93)
									}
								}
							}

							add(rulefloat, position87)
						}
						add(rulePegText, position86)
					}
					{
						add(ruleAction4, position)
					}
					goto l60
				l85:
					position, tokenIndex = position60, tokenIndex60
					{
						switch buffer[position] {
						case '{':
							{
								position102 := position
								if buffer[position] != rune('{') {
									goto l58
								}
								position++
								{
									add(ruleAction11, position)
								}
								if !_rules[rulews]() {
									goto l58
								}
								{
									position104 := position
								l105:
									{
										position106, tokenIndex106 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l106
										}
										{
											position107, tokenIndex107 := position, tokenIndex
											{
												position109 := position
												if !_rules[rulews]() {
													goto l107
												}
												if buffer[position] != rune(',') {
													goto l107
												}
												position++
												if !_rules[rulews]() {
													goto l107
												}
												add(ruleinlineTableValSep, position109)
											}
											goto l108
										l107:
											position, tokenIndex = position107, tokenIndex107
										}
									l108:
										goto l105
									l106:
										position, tokenIndex = position106, tokenIndex106
									}
									add(ruleinlineTableKeyValues, position104)
								}
								if !_rules[rulews]() {
									goto l58
								}
								if buffer[position] != rune('}') {
									goto l58
								}
								position++
								{
									add(ruleAction12, position)
								}
								add(ruleinlineTable, position102)
							}
						case '[':
							{
								position111 := position
								{
									position112 := position
									if buffer[position] != rune('[') {
										goto l58
									}
									position++
									{
										add(ruleAction23, position)
									}
									if !_rules[rulewsnl]() {
										goto l58
									}
									{
										position114, tokenIndex114 := position, tokenIndex
										{
											position116 := position
											if !_rules[ruleval]() {
												goto l114
											}
											{
												add(ruleAction24, position)
											}
										l118:
											{
												position119, tokenIndex119 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l119
												}
												{
													position120, tokenIndex120 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l120
													}
													goto l121
												l120:
													position, tokenIndex = position120, tokenIndex120
												}
											l121:
												if !_rules[rulewsnl]() {
													goto l119
												}
												if !_rules[rulearraySep]() {
													goto l119
												}
												if !_rules[rulewsnl]() {
													goto l119
												}
												{
													position122, tokenIndex122 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l122
													}
													goto l123
												l122:
													position, tokenIndex = position122, tokenIndex122
												}
											l123:
												if !_rules[rulewsnl]() {
													goto l119
												}
												if !_rules[ruleval]() {
													goto l119
												}
												{
													add(ruleAction25, position)
												}
												goto l118
											l119:
												position, tokenIndex = position119, tokenIndex119
											}
											if !_rules[rulewsnl]() {
												goto l114
											}
											{
												position125, tokenIndex125 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l125
												}
												goto l126
											l125:
												position, tokenIndex = position125, tokenIndex125
											}
										l126:
											if !_rules[rulewsnl]() {
												goto l114
											}
											{
												position127, tokenIndex127 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l127
												}
												goto l128
											l127:
												position, tokenIndex = position127, tokenIndex127
											}
										l128:
											add(rulearrayValues, position116)
										}
										goto l115
									l114:
										position, tokenIndex = position114, tokenIndex114
									}
								l115:
									if !_rules[rulewsnl]() {
										goto l58
									}
									if buffer[position] != rune(']') {
										goto l58
									}
									position++
									add(rulearray, position112)
								}
								add(rulePegText, position111)
							}
							{
								add(ruleAction8, position)
							}
						case 'f', 't':
							{
								position130 := position
								{
									position131 := position
									{
										position132, tokenIndex132 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l133
										}
										position++
										if buffer[position] != rune('r') {
											goto l133
										}
										position++
										if buffer[position] != rune('u') {
											goto l133
										}
										position++
										if buffer[position] != rune('e') {
											goto l133
										}
										position++
										goto l132
									l133:
										position, tokenIndex = position132, tokenIndex132
										if buffer[position] != rune('f') {
											goto l58
										}
										position++
										if buffer[position] != rune('a') {
											goto l58
										}
										position++
										if buffer[position] != rune('l') {
											goto l58
										}
										position++
										if buffer[position] != rune('s') {
											goto l58
										}
										position++
										if buffer[position] != rune('e') {
											goto l58
										}
										position++
									}
								l132:
									add(ruleboolean, position131)
								}
								add(rulePegText, position130)
							}
							{
								add(ruleAction7, position)
							}
						case '"', '\'':
							{
								position135 := position
								{
									position136 := position
									{
										position137, tokenIndex137 := position, tokenIndex
										{
											position139 := position
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											{
												position140 := position
												{
													position141 := position
												l142:
													{
														position143, tokenIndex143 := position, tokenIndex
														{
															position144, tokenIndex144 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l144
															}
															position++
															if buffer[position] != rune('\'') {
																goto l144
															}
															position++
															if buffer[position] != rune('\'') {
																goto l144
															}
															position++
															goto l143
														l144:
															position, tokenIndex = position144, tokenIndex144
														}
														{
															position145, tokenIndex145 := position, tokenIndex
															{
																position147 := position
																{
																	position148, tokenIndex148 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l149
																	}
																	position++
																	goto l148
																l149:
																	position, tokenIndex = position148, tokenIndex148
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l146
																	}
																	position++
																}
															l148:
																add(rulemlLiteralChar, position147)
															}
															goto l145
														l146:
															position, tokenIndex = position145, tokenIndex145
															if !_rules[rulenewline]() {
																goto l143
															}
														}
													l145:
														goto l142
													l143:
														position, tokenIndex = position143, tokenIndex143
													}
													add(rulemlLiteralBody, position141)
												}
												add(rulePegText, position140)
											}
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											if buffer[position] != rune('\'') {
												goto l138
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(rulemlLiteralString, position139)
										}
										goto l137
									l138:
										position, tokenIndex = position137, tokenIndex137
										{
											position152 := position
											if buffer[position] != rune('\'') {
												goto l151
											}
											position++
											{
												position153 := position
											l154:
												{
													position155, tokenIndex155 := position, tokenIndex
													{
														position156 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l155
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l155
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l155
																}
																position++
															}
														}

														add(ruleliteralChar, position156)
													}
													goto l154
												l155:
													position, tokenIndex = position155, tokenIndex155
												}
												add(rulePegText, position153)
											}
											if buffer[position] != rune('\'') {
												goto l151
											}
											position++
											{
												add(ruleAction21, position)
											}
											add(ruleliteralString, position152)
										}
										goto l137
									l151:
										position, tokenIndex = position137, tokenIndex137
										{
											position160 := position
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											{
												position161 := position
											l162:
												{
													position163, tokenIndex163 := position, tokenIndex
													{
														position164, tokenIndex164 := position, tokenIndex
														{
															position166, tokenIndex166 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l166
															}
															position++
															if buffer[position] != rune('"') {
																goto l166
															}
															position++
															if buffer[position] != rune('"') {
																goto l166
															}
															position++
															goto l165
														l166:
															position, tokenIndex = position166, tokenIndex166
														}
														if buffer[position] != rune('"') {
															goto l165
														}
														position++
														{
															add(ruleAction19, position)
														}
														goto l164
													l165:
														position, tokenIndex = position164, tokenIndex164
														{
															position169 := position
															{
																position170, tokenIndex170 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l171
																}
																goto l170
															l171:
																position, tokenIndex = position170, tokenIndex170
																if !_rules[rulenewline]() {
																	goto l168
																}
															}
														l170:
															add(rulePegText, position169)
														}
														{
															add(ruleAction20, position)
														}
														goto l164
													l168:
														position, tokenIndex = position164, tokenIndex164
														if !_rules[ruleescape]() {
															goto l163
														}
														if !_rules[rulenewline]() {
															goto l163
														}
														if !_rules[rulewsnl]() {
															goto l163
														}
													}
												l164:
													goto l162
												l163:
													position, tokenIndex = position163, tokenIndex163
												}
												add(rulemlBasicBody, position161)
											}
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											if buffer[position] != rune('"') {
												goto l159
											}
											position++
											{
												add(ruleAction18, position)
											}
											add(rulemlBasicString, position160)
										}
										goto l137
									l159:
										position, tokenIndex = position137, tokenIndex137
										{
											position174 := position
											{
												position175 := position
												if buffer[position] != rune('"') {
													goto l58
												}
												position++
											l176:
												{
													position177, tokenIndex177 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l177
													}
													goto l176
												l177:
													position, tokenIndex = position177, tokenIndex177
												}
												if buffer[position] != rune('"') {
													goto l58
												}
												position++
												add(rulePegText, position175)
											}
											{
												add(ruleAction17, position)
											}
											add(rulebasicString, position174)
										}
									}
								l137:
									add(rulestring, position136)
								}
								add(rulePegText, position135)
							}
							{
								add(ruleAction6, position)
							}
						default:
							{
								position180 := position
								{
									position181 := position
									{
										switch buffer[position] {
										case '-':
											if buffer[position] != rune('-') {
												goto l58
											}
											position++
											if !_rules[ruleanyInt]() {
												goto l58
											}
										case '+':
											if buffer[position] != rune('+') {
												goto l58
											}
											position++
											if !_rules[ruledecimalInt]() {
												goto l58
											}
										default:
											if !_rules[ruleanyInt]() {
												goto l58
											}
										}
									}

									add(ruleinteger, position181)
								}
								add(rulePegText, position180)
							}
							{
								add(ruleAction5, position)
							}
						}
					}

				}
			l60:
				add(ruleval, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 7 table <- <(stdTable / arrayTable)> */
		nil,
		/* 8 stdTable <- <('[' ws <tableKey> ws ']' Action9)> */
		nil,
		/* 9 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action10)> */
		nil,
		/* 10 inlineTable <- <('{' Action11 ws inlineTableKeyValues ws '}' Action12)> */
		nil,
		/* 11 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 12 keyval <- <(key ws '=' ws val Action13)> */
		func() bool {
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				if !_rules[rulekey]() {
					goto l189
				}
				if !_rules[rulews]() {
					goto l189
				}
				if buffer[position] != rune('=') {
					goto l189
				}
				position++
				if !_rules[rulews]() {
					goto l189
				}
				if !_rules[ruleval]() {
					goto l189
				}
				{
					add(ruleAction13, position)
				}
				add(rulekeyval, position190)
			}
			return true
		l189:
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 13 key <- <(bareKey / quotedKey)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					{
						position196 := position
						{
							position197 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l195
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l195
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l195
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l195
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l195
									}
									position++
								}
							}

						l198:
							{
								position199, tokenIndex199 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l199
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l199
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l199
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l199
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l199
										}
										position++
									}
								}

								goto l198
							l199:
								position, tokenIndex = position199, tokenIndex199
							}
							add(rulePegText, position197)
						}
						{
							add(ruleAction14, position)
						}
						add(rulebareKey, position196)
					}
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					{
						position203 := position
						{
							position204 := position
							if buffer[position] != rune('"') {
								goto l192
							}
							position++
						l205:
							{
								position206, tokenIndex206 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l206
								}
								goto l205
							l206:
								position, tokenIndex = position206, tokenIndex206
							}
							if buffer[position] != rune('"') {
								goto l192
							}
							position++
							add(rulePegText, position204)
						}
						{
							add(ruleAction15, position)
						}
						add(rulequotedKey, position203)
					}
				}
			l194:
				add(rulekey, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 14 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action14)> */
		nil,
		/* 15 quotedKey <- <(<('"' basicChar* '"')> Action15)> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position210, tokenIndex210 := position, tokenIndex
			{
				position211 := position
				if !_rules[ruletableKeyComp]() {
					goto l210
				}
			l212:
				{
					position213, tokenIndex213 := position, tokenIndex
					{
						position214 := position
						if !_rules[rulews]() {
							goto l213
						}
						if buffer[position] != rune('.') {
							goto l213
						}
						position++
						if !_rules[rulews]() {
							goto l213
						}
						add(ruletableKeySep, position214)
					}
					if !_rules[ruletableKeyComp]() {
						goto l213
					}
					goto l212
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
				add(ruletableKey, position211)
			}
			return true
		l210:
			position, tokenIndex = position210, tokenIndex210
			return false
		},
		/* 17 tableKeyComp <- <(key Action16)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if !_rules[rulekey]() {
					goto l215
				}
				{
					add(ruleAction16, position)
				}
				add(ruletableKeyComp, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 21 integer <- <((&('-') ('-' anyInt)) | (&('+') ('+' decimalInt)) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') anyInt))> */
		nil,
		/* 22 anyInt <- <(hexInt / octalInt / binaryInt / decimalInt)> */
		func() bool {
			position222, tokenIndex222 := position, tokenIndex
			{
				position223 := position
				{
					position224, tokenIndex224 := position, tokenIndex
					{
						position226 := position
						if buffer[position] != rune('0') {
							goto l225
						}
						position++
						if buffer[position] != rune('x') {
							goto l225
						}
						position++
						if !_rules[rulehexDigit]() {
							goto l225
						}
					l227:
						{
							position228, tokenIndex228 := position, tokenIndex
							{
								position229, tokenIndex229 := position, tokenIndex
								if !_rules[rulehexDigit]() {
									goto l230
								}
								goto l229
							l230:
								position, tokenIndex = position229, tokenIndex229
								if buffer[position] != rune('_') {
									goto l228
								}
								position++
								if !_rules[rulehexDigit]() {
									goto l228
								}
							}
						l229:
							goto l227
						l228:
							position, tokenIndex = position228, tokenIndex228
						}
						add(rulehexInt, position226)
					}
					goto l224
				l225:
					position, tokenIndex = position224, tokenIndex224
					{
						position232 := position
						if buffer[position] != rune('0') {
							goto l231
						}
						position++
						if buffer[position] != rune('o') {
							goto l231
						}
						position++
						if !_rules[ruleoctalDigit]() {
							goto l231
						}
					l233:
						{
							position234, tokenIndex234 := position, tokenIndex
							{
								position235, tokenIndex235 := position, tokenIndex
								if !_rules[ruleoctalDigit]() {
									goto l236
								}
								goto l235
							l236:
								position, tokenIndex = position235, tokenIndex235
								if buffer[position] != rune('_') {
									goto l234
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l234
								}
							}
						l235:
							goto l233
						l234:
							position, tokenIndex = position234, tokenIndex234
						}
						add(ruleoctalInt, position232)
					}
					goto l224
				l231:
					position, tokenIndex = position224, tokenIndex224
					{
						position238 := position
						if buffer[position] != rune('0') {
							goto l237
						}
						position++
						if buffer[position] != rune('b') {
							goto l237
						}
						position++
						if !_rules[rulebinaryDigit]() {
							goto l237
						}
					l239:
						{
							position240, tokenIndex240 := position, tokenIndex
							{
								position241, tokenIndex241 := position, tokenIndex
								if !_rules[rulebinaryDigit]() {
									goto l242
								}
								goto l241
							l242:
								position, tokenIndex = position241, tokenIndex241
								if buffer[position] != rune('_') {
									goto l240
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l240
								}
							}
						l241:
							goto l239
						l240:
							position, tokenIndex = position240, tokenIndex240
						}
						add(rulebinaryInt, position238)
					}
					goto l224
				l237:
					position, tokenIndex = position224, tokenIndex224
					if !_rules[ruledecimalInt]() {
						goto l222
					}
				}
			l224:
				add(ruleanyInt, position223)
			}
			return true
		l222:
			position, tokenIndex = position222, tokenIndex222
			return false
		},
		/* 23 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l246
					}
					position++
					{
						position249, tokenIndex249 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l250
						}
						goto l249
					l250:
						position, tokenIndex = position249, tokenIndex249
						if buffer[position] != rune('_') {
							goto l246
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l246
						}
					}
				l249:
				l247:
					{
						position248, tokenIndex248 := position, tokenIndex
						{
							position251, tokenIndex251 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l252
							}
							goto l251
						l252:
							position, tokenIndex = position251, tokenIndex251
							if buffer[position] != rune('_') {
								goto l248
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l248
							}
						}
					l251:
						goto l247
					l248:
						position, tokenIndex = position248, tokenIndex248
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruledecimalDigit]() {
						goto l243
					}
				}
			l245:
				add(ruledecimalInt, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 24 decimalDigit <- <[0-9]> */
		func() bool {
			position253, tokenIndex253 := position, tokenIndex
			{
				position254 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l253
				}
				position++
				add(ruledecimalDigit, position254)
			}
			return true
		l253:
			position, tokenIndex = position253, tokenIndex253
			return false
		},
		/* 25 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 26 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l256
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l256
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l256
						}
						position++
					}
				}

				add(rulehexDigit, position257)
			}
			return true
		l256:
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 27 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 28 octalDigit <- <[0-7]> */
		func() bool {
			position260, tokenIndex260 := position, tokenIndex
			{
				position261 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l260
				}
				position++
				add(ruleoctalDigit, position261)
			}
			return true
		l260:
			position, tokenIndex = position260, tokenIndex260
			return false
		},
		/* 29 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 30 binaryDigit <- <('0' / '1')> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				{
					position265, tokenIndex265 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l266
					}
					position++
					goto l265
				l266:
					position, tokenIndex = position265, tokenIndex265
					if buffer[position] != rune('1') {
						goto l263
					}
					position++
				}
			l265:
				add(rulebinaryDigit, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 31 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 32 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 33 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position269, tokenIndex269 := position, tokenIndex
			{
				position270 := position
				if buffer[position] != rune('.') {
					goto l269
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l269
				}
			l271:
				{
					position272, tokenIndex272 := position, tokenIndex
					{
						position273, tokenIndex273 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l274
						}
						goto l273
					l274:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('_') {
							goto l272
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l272
						}
					}
				l273:
					goto l271
				l272:
					position, tokenIndex = position272, tokenIndex272
				}
				add(rulefloatFrac, position270)
			}
			return true
		l269:
			position, tokenIndex = position269, tokenIndex269
			return false
		},
		/* 34 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				{
					position277, tokenIndex277 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l278
					}
					position++
					goto l277
				l278:
					position, tokenIndex = position277, tokenIndex277
					if buffer[position] != rune('E') {
						goto l275
					}
					position++
				}
			l277:
				{
					position279, tokenIndex279 := position, tokenIndex
					{
						position281, tokenIndex281 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l282
						}
						position++
						goto l281
					l282:
						position, tokenIndex = position281, tokenIndex281
						if buffer[position] != rune('+') {
							goto l279
						}
						position++
					}
				l281:
					goto l280
				l279:
					position, tokenIndex = position279, tokenIndex279
				}
			l280:
				if !_rules[ruledecimalDigit]() {
					goto l275
				}
			l283:
				{
					position284, tokenIndex284 := position, tokenIndex
					{
						position285, tokenIndex285 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l286
						}
						goto l285
					l286:
						position, tokenIndex = position285, tokenIndex285
						if buffer[position] != rune('_') {
							goto l284
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l284
						}
					}
				l285:
					goto l283
				l284:
					position, tokenIndex = position284, tokenIndex284
				}
				add(rulefloatExp, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 35 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 36 escape <- <'\\'> */
		func() bool {
			position288, tokenIndex288 := position, tokenIndex
			{
				position289 := position
				if buffer[position] != rune('\\') {
					goto l288
				}
				position++
				add(ruleescape, position289)
			}
			return true
		l288:
			position, tokenIndex = position288, tokenIndex288
			return false
		},
		/* 37 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position290, tokenIndex290 := position, tokenIndex
			{
				position291 := position
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				add(rulehexQuad, position291)
			}
			return true
		l290:
			position, tokenIndex = position290, tokenIndex290
			return false
		},
		/* 38 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 39 basicString <- <(<('"' basicChar* '"')> Action17)> */
		nil,
		/* 40 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position294, tokenIndex294 := position, tokenIndex
			{
				position295 := position
				{
					position296, tokenIndex296 := position, tokenIndex
					{
						position298 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l297
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l297
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l297
								}
								position++
							}
						}

						add(rulebasicUnescaped, position298)
					}
					goto l296
				l297:
					position, tokenIndex = position296, tokenIndex296
					{
						position300 := position
						if !_rules[ruleescape]() {
							goto l294
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l294
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l294
								}
								if !_rules[rulehexQuad]() {
									goto l294
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l294
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l294
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l294
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l294
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l294
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l294
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l294
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l294
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l294
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l294
								}
								position++
							}
						}

						add(ruleescaped, position300)
					}
				}
			l296:
				add(rulebasicChar, position295)
			}
			return true
		l294:
			position, tokenIndex = position294, tokenIndex294
			return false
		},
		/* 41 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') []-\U0010ffff]))> */
		nil,
		/* 42 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action18)> */
		nil,
		/* 43 mlBasicBody <- <((!('"' '"' '"') '"' Action19) / (<(basicChar / newline)> Action20) / (escape newline wsnl))*> */
		nil,
		/* 44 literalString <- <('\'' <literalChar*> '\'' Action21)> */
		nil,
		/* 45 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') [(-\U0010ffff]))> */
		nil,
		/* 46 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action22)> */
		nil,
		/* 47 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 48 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 49 dateFullYear <- <digitQuad> */
		nil,
		/* 50 dateMonth <- <digitDual> */
		nil,
		/* 51 dateMDay <- <digitDual> */
		nil,
		/* 52 timeHour <- <digitDual> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if !_rules[ruledigitDual]() {
					goto l313
				}
				add(ruletimeHour, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 53 timeMinute <- <digitDual> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if !_rules[ruledigitDual]() {
					goto l315
				}
				add(ruletimeMinute, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 54 timeSecond <- <digitDual> */
		nil,
		/* 55 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 56 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 57 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 58 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				if !_rules[ruletimeHour]() {
					goto l321
				}
				if buffer[position] != rune(':') {
					goto l321
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l321
				}
				if buffer[position] != rune(':') {
					goto l321
				}
				position++
				{
					position323 := position
					if !_rules[ruledigitDual]() {
						goto l321
					}
					add(ruletimeSecond, position323)
				}
				{
					position324, tokenIndex324 := position, tokenIndex
					{
						position326 := position
						if buffer[position] != rune('.') {
							goto l324
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l324
						}
					l327:
						{
							position328, tokenIndex328 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l328
							}
							goto l327
						l328:
							position, tokenIndex = position328, tokenIndex328
						}
						add(ruletimeSecfrac, position326)
					}
					goto l325
				l324:
					position, tokenIndex = position324, tokenIndex324
				}
			l325:
				add(rulepartialTime, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 59 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 60 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 61 datetime <- <((fullDate (('T' / ' ') fullTime)?) / partialTime)> */
		nil,
		/* 62 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if !_rules[ruledecimalDigit]() {
					goto l332
				}
				if !_rules[ruledecimalDigit]() {
					goto l332
				}
				add(ruledigitDual, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 63 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 64 array <- <('[' Action23 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 65 arrayValues <- <(val Action24 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action25)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 66 arraySep <- <','> */
		func() bool {
			position337, tokenIndex337 := position, tokenIndex
			{
				position338 := position
				if buffer[position] != rune(',') {
					goto l337
				}
				position++
				add(rulearraySep, position338)
			}
			return true
		l337:
			position, tokenIndex = position337, tokenIndex337
			return false
		},
		/* 68 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 70 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 71 Action2 <- <{ p.Newline() }> */
		nil,
		/* 72 Action3 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 73 Action4 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 74 Action5 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 75 Action6 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 76 Action7 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 77 Action8 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 78 Action9 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 79 Action10 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 80 Action11 <- <{ p.StartInlineTable() }> */
		nil,
		/* 81 Action12 <- <{ p.EndInlineTable() }> */
		nil,
		/* 82 Action13 <- <{ p.AddKeyValue() }> */
		nil,
		/* 83 Action14 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 84 Action15 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 85 Action16 <- <{ p.AddTableKey() }> */
		nil,
		/* 86 Action17 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action18 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 88 Action19 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 89 Action20 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 90 Action21 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 91 Action22 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 92 Action23 <- <{ p.StartArray() }> */
		nil,
		/* 93 Action24 <- <{ p.AddArrayVal() }> */
		nil,
		/* 94 Action25 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
