package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulenewlineRequired
	rulews
	rulewsnl
	rulecomment
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTable
	ruleinlineTableKeyValues
	ruleinlineTableCommaForbidden
	ruleinlineTableCommaRequired
	ruleboolean
	ruleinteger
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledatetime
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"newlineRequired",
	"ws",
	"wsnl",
	"comment",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTable",
	"inlineTableKeyValues",
	"inlineTableCommaForbidden",
	"inlineTableCommaRequired",
	"boolean",
	"integer",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"datetime",
	"partialTime",
	"fullDate",
	"fullTime",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [100]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableSource(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.Error(errNewlineRequired)
		case ruleAction4:
			p.SetTime(begin, end)
		case ruleAction5:
			p.SetFloat(begin, end)
		case ruleAction6:
			p.SetInteger(begin, end)
		case ruleAction7:
			p.SetString(begin, end)
		case ruleAction8:
			p.SetBool(begin, end)
		case ruleAction9:
			p.SetArray(begin, end)
		case ruleAction10:
			p.SetInlineTableSource(begin, end)
		case ruleAction11:
			p.SetTable(p.buffer, begin, end)
		case ruleAction12:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction13:
			p.AddKeyValue()
		case ruleAction14:
			p.SetKey(p.buffer, begin, end)
		case ruleAction15:
			p.SetKey(p.buffer, begin, end)
		case ruleAction16:
			p.AddTableKey()
		case ruleAction17:
			p.StartInlineTable()
		case ruleAction18:
			p.EndInlineTable()
		case ruleAction19:
			p.Error(errInlineTableCommaAtEnd)
		case ruleAction20:
			p.Error(errInlineTableCommaRequired)
		case ruleAction21:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction22:
			p.SetMultilineBasicString()
		case ruleAction23:
			p.AddMultilineBasicQuote()
		case ruleAction24:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction25:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction26:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction27:
			p.StartArray()
		case ruleAction28:
			p.AddArrayVal()
		case ruleAction29:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (ws newlineRequired wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction11, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction12, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26 := position
								{
									position27, tokenIndex27 := position, tokenIndex
									{
										position29, tokenIndex29 := position, tokenIndex
										if !_rules[rulenewline]() {
											goto l29
										}
										goto l28
									l29:
										position, tokenIndex = position29, tokenIndex29
									}
									{
										add(ruleAction3, position)
									}
									goto l27
								l28:
									position, tokenIndex = position27, tokenIndex27
									if !_rules[rulenewline]() {
										goto l25
									}
								}
							l27:
								add(rulenewlineRequired, position26)
							}
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position31, tokenIndex31 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l31
								}
								goto l32
							l31:
								position, tokenIndex = position31, tokenIndex31
							}
						l32:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l34
					}
					if !_rules[rulekeyval]() {
						goto l34
					}
					if !_rules[rulews]() {
						goto l34
					}
					{
						position35, tokenIndex35 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l35
						}
						goto l36
					l35:
						position, tokenIndex = position35, tokenIndex35
					}
				l36:
					goto l10
				l34:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l37
					}
					{
						position38, tokenIndex38 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l38
						}
						goto l39
					l38:
						position, tokenIndex = position38, tokenIndex38
					}
				l39:
					goto l10
				l37:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				{
					position42, tokenIndex42 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l43
					}
					position++
					if buffer[position] != rune('\n') {
						goto l43
					}
					position++
					goto l42
				l43:
					position, tokenIndex = position42, tokenIndex42
					if buffer[position] != rune('\n') {
						goto l40
					}
					position++
				}
			l42:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 3 newlineRequired <- <((!newline Action3) / newline)> */
		nil,
		/* 4 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						position50, tokenIndex50 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l51
						}
						position++
						goto l50
					l51:
						position, tokenIndex = position50, tokenIndex50
						if buffer[position] != rune('\t') {
							goto l49
						}
						position++
					}
				l50:
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulews, position47)
			}
			return true
		},
		/* 5 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position53 := position
			l54:
				{
					position55, tokenIndex55 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l55
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l55
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l55
							}
						}
					}

					goto l54
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
				add(rulewsnl, position53)
			}
			return true
		},
		/* 6 comment <- <('#' ('\t' / [ -\U0010ffff])*)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if buffer[position] != rune('#') {
					goto l57
				}
				position++
			l59:
				{
					position60, tokenIndex60 := position, tokenIndex
					{
						position61, tokenIndex61 := position, tokenIndex
						if buffer[position] != rune('\t') {
							goto l62
						}
						position++
						goto l61
					l62:
						position, tokenIndex = position61, tokenIndex61
						if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
							goto l60
						}
						position++
					}
				l61:
					goto l59
				l60:
					position, tokenIndex = position60, tokenIndex60
				}
				add(rulecomment, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 7 val <- <((<datetime> Action4) / (<float> Action5) / ((&('{') (<inlineTable> Action10)) | (&('[') (<array> Action9)) | (&('f' | 't') (<boolean> Action8)) | (&('"' | '\'') (<string> Action7)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action6))))> */
		func() bool {
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				{
					position65, tokenIndex65 := position, tokenIndex
					{
						position67 := position
						{
							position68 := position
							{
								position69, tokenIndex69 := position, tokenIndex
								{
									position71 := position
									{
										position72 := position
										{
											position73 := position
											if !_rules[ruledigitDual]() {
												goto l70
											}
											if !_rules[ruledigitDual]() {
												goto l70
											}
											add(ruledigitQuad, position73)
										}
										add(ruledateFullYear, position72)
									}
									if buffer[position] != rune('-') {
										goto l70
									}
									position++
									{
										position74 := position
										if !_rules[ruledigitDual]() {
											goto l70
										}
										add(ruledateMonth, position74)
									}
									if buffer[position] != rune('-') {
										goto l70
									}
									position++
									{
										position75 := position
										if !_rules[ruledigitDual]() {
											goto l70
										}
										add(ruledateMDay, position75)
									}
									add(rulefullDate, position71)
								}
								{
									position76, tokenIndex76 := position, tokenIndex
									{
										switch buffer[position] {
										case ' ':
											if buffer[position] != rune(' ') {
												goto l76
											}
											position++
										case 't':
											if buffer[position] != rune('t') {
												goto l76
											}
											position++
										default:
											if buffer[position] != rune('T') {
												goto l76
											}
											position++
										}
									}

									{
										position79 := position
										if !_rules[rulepartialTime]() {
											goto l76
										}
										{
											position80, tokenIndex80 := position, tokenIndex
											{
												position82 := position
												{
													switch buffer[position] {
													case 'z':
														if buffer[position] != rune('z') {
															goto l80
														}
														position++
													case 'Z':
														if buffer[position] != rune('Z') {
															goto l80
														}
														position++
													default:
														{
															position84 := position
															{
																position85, tokenIndex85 := position, tokenIndex
																if buffer[position] != rune('-') {
																	goto l86
																}
																position++
																goto l85
															l86:
																position, tokenIndex = position85, tokenIndex85
																if buffer[position] != rune('+') {
																	goto l80
																}
																position++
															}
														l85:
															if !_rules[ruletimeHour]() {
																goto l80
															}
															if buffer[position] != rune(':') {
																goto l80
															}
															position++
															if !_rules[ruletimeMinute]() {
																goto l80
															}
															add(ruletimeNumoffset, position84)
														}
													}
												}

												add(ruletimeOffset, position82)
											}
											goto l81
										l80:
											position, tokenIndex = position80, tokenIndex80
										}
									l81:
										add(rulefullTime, position79)
									}
									goto l77
								l76:
									position, tokenIndex = position76, tokenIndex76
								}
							l77:
								goto l69
							l70:
								position, tokenIndex = position69, tokenIndex69
								if !_rules[rulepartialTime]() {
									goto l66
								}
							}
						l69:
							add(ruledatetime, position68)
						}
						add(rulePegText, position67)
					}
					{
						add(ruleAction4, position)
					}
					goto l65
				l66:
					position, tokenIndex = position65, tokenIndex65
					{
						position89 := position
						{
							position90 := position
							{
								position91, tokenIndex91 := position, tokenIndex
								{
									position93, tokenIndex93 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l94
									}
									position++
									goto l93
								l94:
									position, tokenIndex = position93, tokenIndex93
									if buffer[position] != rune('-') {
										goto l91
									}
									position++
								}
							l93:
								goto l92
							l91:
								position, tokenIndex = position91, tokenIndex91
							}
						l92:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l88
									}
									position++
									if buffer[position] != rune('n') {
										goto l88
									}
									position++
									if buffer[position] != rune('f') {
										goto l88
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l88
									}
									position++
									if buffer[position] != rune('a') {
										goto l88
									}
									position++
									if buffer[position] != rune('n') {
										goto l88
									}
									position++
								default:
									{
										position96 := position
										if !_rules[ruledecimalInt]() {
											goto l88
										}
										{
											position97, tokenIndex97 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l98
											}
											{
												position99, tokenIndex99 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l99
												}
												goto l100
											l99:
												position, tokenIndex = position99, tokenIndex99
											}
										l100:
											goto l97
										l98:
											position, tokenIndex = position97, tokenIndex97
											{
												position101, tokenIndex101 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l101
												}
												goto l102
											l101:
												position, tokenIndex = position101, tokenIndex101
											}
										l102:
											if !_rules[rulefloatExp]() {
												goto l88
											}
										}
									l97:
										add(rulefloatDigits, position96)
									}
								}
							}

							add(rulefloat, position90)
						}
						add(rulePegText, position89)
					}
					{
						add(ruleAction5, position)
					}
					goto l65
				l88:
					position, tokenIndex = position65, tokenIndex65
					{
						switch buffer[position] {
						case '{':
							{
								position105 := position
								{
									position106 := position
									if buffer[position] != rune('{') {
										goto l63
									}
									position++
									{
										add(ruleAction17, position)
									}
									if !_rules[rulews]() {
										goto l63
									}
									{
										position108, tokenIndex108 := position, tokenIndex
										{
											position110 := position
											if !_rules[rulekeyval]() {
												goto l108
											}
										l111:
											{
												position112, tokenIndex112 := position, tokenIndex
												if !_rules[rulews]() {
													goto l112
												}
												{
													position113 := position
													{
														position114, tokenIndex114 := position, tokenIndex
														{
															position116, tokenIndex116 := position, tokenIndex
															if buffer[position] != rune(',') {
																goto l116
															}
															position++
															goto l115
														l116:
															position, tokenIndex = position116, tokenIndex116
														}
														{
															add(ruleAction20, position)
														}
														goto l114
													l115:
														position, tokenIndex = position114, tokenIndex114
														if buffer[position] != rune(',') {
															goto l112
														}
														position++
													}
												l114:
													add(ruleinlineTableCommaRequired, position113)
												}
												if !_rules[rulews]() {
													goto l112
												}
												if !_rules[rulekeyval]() {
													goto l112
												}
												goto l111
											l112:
												position, tokenIndex = position112, tokenIndex112
											}
											if !_rules[rulews]() {
												goto l108
											}
											{
												position118 := position
												{
													position119, tokenIndex119 := position, tokenIndex
													{
														position121, tokenIndex121 := position, tokenIndex
														if buffer[position] != rune(',') {
															goto l121
														}
														position++
														goto l120
													l121:
														position, tokenIndex = position121, tokenIndex121
													}
													goto l119
												l120:
													position, tokenIndex = position119, tokenIndex119
													if buffer[position] != rune(',') {
														goto l108
													}
													position++
													{
														add(ruleAction19, position)
													}
												}
											l119:
												add(ruleinlineTableCommaForbidden, position118)
											}
											add(ruleinlineTableKeyValues, position110)
										}
										goto l109
									l108:
										position, tokenIndex = position108, tokenIndex108
									}
								l109:
									if !_rules[rulews]() {
										goto l63
									}
									if buffer[position] != rune('}') {
										goto l63
									}
									position++
									{
										add(ruleAction18, position)
									}
									add(ruleinlineTable, position106)
								}
								add(rulePegText, position105)
							}
							{
								add(ruleAction10, position)
							}
						case '[':
							{
								position125 := position
								{
									position126 := position
									if buffer[position] != rune('[') {
										goto l63
									}
									position++
									{
										add(ruleAction27, position)
									}
									if !_rules[rulewsnl]() {
										goto l63
									}
									{
										position128, tokenIndex128 := position, tokenIndex
										{
											position130 := position
										l131:
											{
												position132, tokenIndex132 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l132
												}
												if !_rules[rulecomment]() {
													goto l132
												}
												goto l131
											l132:
												position, tokenIndex = position132, tokenIndex132
											}
											if !_rules[rulewsnl]() {
												goto l128
											}
											if !_rules[ruleval]() {
												goto l128
											}
											{
												add(ruleAction28, position)
											}
										l134:
											{
												position135, tokenIndex135 := position, tokenIndex
											l136:
												{
													position137, tokenIndex137 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l137
													}
													if !_rules[rulecomment]() {
														goto l137
													}
													goto l136
												l137:
													position, tokenIndex = position137, tokenIndex137
												}
												if !_rules[rulewsnl]() {
													goto l135
												}
												if !_rules[rulearraySep]() {
													goto l135
												}
											l138:
												{
													position139, tokenIndex139 := position, tokenIndex
													if !_rules[rulewsnl]() {
														goto l139
													}
													if !_rules[rulecomment]() {
														goto l139
													}
													goto l138
												l139:
													position, tokenIndex = position139, tokenIndex139
												}
												if !_rules[rulewsnl]() {
													goto l135
												}
												if !_rules[ruleval]() {
													goto l135
												}
												{
													add(ruleAction29, position)
												}
												goto l134
											l135:
												position, tokenIndex = position135, tokenIndex135
											}
										l141:
											{
												position142, tokenIndex142 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l142
												}
												if !_rules[rulecomment]() {
													goto l142
												}
												goto l141
											l142:
												position, tokenIndex = position142, tokenIndex142
											}
											if !_rules[rulewsnl]() {
												goto l128
											}
											{
												position143, tokenIndex143 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l143
												}
												goto l144
											l143:
												position, tokenIndex = position143, tokenIndex143
											}
										l144:
										l145:
											{
												position146, tokenIndex146 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l146
												}
												if !_rules[rulecomment]() {
													goto l146
												}
												goto l145
											l146:
												position, tokenIndex = position146, tokenIndex146
											}
											add(rulearrayValues, position130)
										}
										goto l129
									l128:
										position, tokenIndex = position128, tokenIndex128
									}
								l129:
									if !_rules[rulewsnl]() {
										goto l63
									}
									if buffer[position] != rune(']') {
										goto l63
									}
									position++
									add(rulearray, position126)
								}
								add(rulePegText, position125)
							}
							{
								add(ruleAction9, position)
							}
						case 'f', 't':
							{
								position148 := position
								{
									position149 := position
									{
										position150, tokenIndex150 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l151
										}
										position++
										if buffer[position] != rune('r') {
											goto l151
										}
										position++
										if buffer[position] != rune('u') {
											goto l151
										}
										position++
										if buffer[position] != rune('e') {
											goto l151
										}
										position++
										goto l150
									l151:
										position, tokenIndex = position150, tokenIndex150
										if buffer[position] != rune('f') {
											goto l63
										}
										position++
										if buffer[position] != rune('a') {
											goto l63
										}
										position++
										if buffer[position] != rune('l') {
											goto l63
										}
										position++
										if buffer[position] != rune('s') {
											goto l63
										}
										position++
										if buffer[position] != rune('e') {
											goto l63
										}
										position++
									}
								l150:
									add(ruleboolean, position149)
								}
								add(rulePegText, position148)
							}
							{
								add(ruleAction8, position)
							}
						case '"', '\'':
							{
								position153 := position
								{
									position154 := position
									{
										position155, tokenIndex155 := position, tokenIndex
										{
											position157 := position
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											{
												position158 := position
												{
													position159 := position
												l160:
													{
														position161, tokenIndex161 := position, tokenIndex
														{
															position162, tokenIndex162 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l162
															}
															position++
															if buffer[position] != rune('\'') {
																goto l162
															}
															position++
															if buffer[position] != rune('\'') {
																goto l162
															}
															position++
															goto l161
														l162:
															position, tokenIndex = position162, tokenIndex162
														}
														{
															position163, tokenIndex163 := position, tokenIndex
															{
																position165 := position
																{
																	position166, tokenIndex166 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l167
																	}
																	position++
																	goto l166
																l167:
																	position, tokenIndex = position166, tokenIndex166
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l164
																	}
																	position++
																}
															l166:
																add(rulemlLiteralChar, position165)
															}
															goto l163
														l164:
															position, tokenIndex = position163, tokenIndex163
															if !_rules[rulenewline]() {
																goto l161
															}
														}
													l163:
														goto l160
													l161:
														position, tokenIndex = position161, tokenIndex161
													}
													add(rulemlLiteralBody, position159)
												}
												add(rulePegText, position158)
											}
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											if buffer[position] != rune('\'') {
												goto l156
											}
											position++
											{
												add(ruleAction26, position)
											}
											add(rulemlLiteralString, position157)
										}
										goto l155
									l156:
										position, tokenIndex = position155, tokenIndex155
										{
											position170 := position
											if buffer[position] != rune('\'') {
												goto l169
											}
											position++
											{
												position171 := position
											l172:
												{
													position173, tokenIndex173 := position, tokenIndex
													{
														position174 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l173
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l173
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l173
																}
																position++
															}
														}

														add(ruleliteralChar, position174)
													}
													goto l172
												l173:
													position, tokenIndex = position173, tokenIndex173
												}
												add(rulePegText, position171)
											}
											if buffer[position] != rune('\'') {
												goto l169
											}
											position++
											{
												add(ruleAction25, position)
											}
											add(ruleliteralString, position170)
										}
										goto l155
									l169:
										position, tokenIndex = position155, tokenIndex155
										{
											position178 := position
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											{
												position179 := position
											l180:
												{
													position181, tokenIndex181 := position, tokenIndex
													{
														position182, tokenIndex182 := position, tokenIndex
														{
															position184, tokenIndex184 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l184
															}
															position++
															if buffer[position] != rune('"') {
																goto l184
															}
															position++
															if buffer[position] != rune('"') {
																goto l184
															}
															position++
															goto l183
														l184:
															position, tokenIndex = position184, tokenIndex184
														}
														if buffer[position] != rune('"') {
															goto l183
														}
														position++
														{
															add(ruleAction23, position)
														}
														goto l182
													l183:
														position, tokenIndex = position182, tokenIndex182
														{
															position187 := position
															{
																position188, tokenIndex188 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l189
																}
																goto l188
															l189:
																position, tokenIndex = position188, tokenIndex188
																if !_rules[rulenewline]() {
																	goto l186
																}
															}
														l188:
															add(rulePegText, position187)
														}
														{
															add(ruleAction24, position)
														}
														goto l182
													l186:
														position, tokenIndex = position182, tokenIndex182
														if !_rules[ruleescape]() {
															goto l181
														}
														if !_rules[rulenewline]() {
															goto l181
														}
														if !_rules[rulewsnl]() {
															goto l181
														}
													}
												l182:
													goto l180
												l181:
													position, tokenIndex = position181, tokenIndex181
												}
												add(rulemlBasicBody, position179)
											}
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											if buffer[position] != rune('"') {
												goto l177
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(rulemlBasicString, position178)
										}
										goto l155
									l177:
										position, tokenIndex = position155, tokenIndex155
										{
											position192 := position
											{
												position193 := position
												if buffer[position] != rune('"') {
													goto l63
												}
												position++
											l194:
												{
													position195, tokenIndex195 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l195
													}
													goto l194
												l195:
													position, tokenIndex = position195, tokenIndex195
												}
												if buffer[position] != rune('"') {
													goto l63
												}
												position++
												add(rulePegText, position193)
											}
											{
												add(ruleAction21, position)
											}
											add(rulebasicString, position192)
										}
									}
								l155:
									add(rulestring, position154)
								}
								add(rulePegText, position153)
							}
							{
								add(ruleAction7, position)
							}
						default:
							{
								position198 := position
								{
									position199 := position
									{
										position200, tokenIndex200 := position, tokenIndex
										{
											position202 := position
											if buffer[position] != rune('0') {
												goto l201
											}
											position++
											if buffer[position] != rune('x') {
												goto l201
											}
											position++
											if !_rules[rulehexDigit]() {
												goto l201
											}
										l203:
											{
												position204, tokenIndex204 := position, tokenIndex
												{
													position205, tokenIndex205 := position, tokenIndex
													if !_rules[rulehexDigit]() {
														goto l206
													}
													goto l205
												l206:
													position, tokenIndex = position205, tokenIndex205
													if buffer[position] != rune('_') {
														goto l204
													}
													position++
													if !_rules[rulehexDigit]() {
														goto l204
													}
												}
											l205:
												goto l203
											l204:
												position, tokenIndex = position204, tokenIndex204
											}
											add(rulehexInt, position202)
										}
										goto l200
									l201:
										position, tokenIndex = position200, tokenIndex200
										{
											position208 := position
											if buffer[position] != rune('0') {
												goto l207
											}
											position++
											if buffer[position] != rune('o') {
												goto l207
											}
											position++
											if !_rules[ruleoctalDigit]() {
												goto l207
											}
										l209:
											{
												position210, tokenIndex210 := position, tokenIndex
												{
													position211, tokenIndex211 := position, tokenIndex
													if !_rules[ruleoctalDigit]() {
														goto l212
													}
													goto l211
												l212:
													position, tokenIndex = position211, tokenIndex211
													if buffer[position] != rune('_') {
														goto l210
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l210
													}
												}
											l211:
												goto l209
											l210:
												position, tokenIndex = position210, tokenIndex210
											}
											add(ruleoctalInt, position208)
										}
										goto l200
									l207:
										position, tokenIndex = position200, tokenIndex200
										{
											position214 := position
											if buffer[position] != rune('0') {
												goto l213
											}
											position++
											if buffer[position] != rune('b') {
												goto l213
											}
											position++
											if !_rules[rulebinaryDigit]() {
												goto l213
											}
										l215:
											{
												position216, tokenIndex216 := position, tokenIndex
												{
													position217, tokenIndex217 := position, tokenIndex
													if !_rules[rulebinaryDigit]() {
														goto l218
													}
													goto l217
												l218:
													position, tokenIndex = position217, tokenIndex217
													if buffer[position] != rune('_') {
														goto l216
													}
													position++
													if !_rules[ruleoctalDigit]() {
														goto l216
													}
												}
											l217:
												goto l215
											l216:
												position, tokenIndex = position216, tokenIndex216
											}
											add(rulebinaryInt, position214)
										}
										goto l200
									l213:
										position, tokenIndex = position200, tokenIndex200
										if !_rules[ruledecimalInt]() {
											goto l219
										}
										goto l200
									l219:
										position, tokenIndex = position200, tokenIndex200
										{
											position220, tokenIndex220 := position, tokenIndex
											if buffer[position] != rune('+') {
												goto l221
											}
											position++
											goto l220
										l221:
											position, tokenIndex = position220, tokenIndex220
											if buffer[position] != rune('-') {
												goto l63
											}
											position++
										}
									l220:
										if !_rules[ruledecimalInt]() {
											goto l63
										}
									}
								l200:
									add(ruleinteger, position199)
								}
								add(rulePegText, position198)
							}
							{
								add(ruleAction6, position)
							}
						}
					}

				}
			l65:
				add(ruleval, position64)
			}
			return true
		l63:
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 8 table <- <(stdTable / arrayTable)> */
		nil,
		/* 9 stdTable <- <('[' ws <tableKey> ws ']' Action11)> */
		nil,
		/* 10 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action12)> */
		nil,
		/* 11 keyval <- <(key ws '=' ws val Action13)> */
		func() bool {
			position226, tokenIndex226 := position, tokenIndex
			{
				position227 := position
				if !_rules[rulekey]() {
					goto l226
				}
				if !_rules[rulews]() {
					goto l226
				}
				if buffer[position] != rune('=') {
					goto l226
				}
				position++
				if !_rules[rulews]() {
					goto l226
				}
				if !_rules[ruleval]() {
					goto l226
				}
				{
					add(ruleAction13, position)
				}
				add(rulekeyval, position227)
			}
			return true
		l226:
			position, tokenIndex = position226, tokenIndex226
			return false
		},
		/* 12 key <- <(bareKey / quotedKey)> */
		func() bool {
			position229, tokenIndex229 := position, tokenIndex
			{
				position230 := position
				{
					position231, tokenIndex231 := position, tokenIndex
					{
						position233 := position
						{
							position234 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l232
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l232
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l232
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l232
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l232
									}
									position++
								}
							}

						l235:
							{
								position236, tokenIndex236 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l236
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l236
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l236
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l236
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l236
										}
										position++
									}
								}

								goto l235
							l236:
								position, tokenIndex = position236, tokenIndex236
							}
							add(rulePegText, position234)
						}
						{
							add(ruleAction14, position)
						}
						add(rulebareKey, position233)
					}
					goto l231
				l232:
					position, tokenIndex = position231, tokenIndex231
					{
						position240 := position
						{
							position241 := position
							if buffer[position] != rune('"') {
								goto l229
							}
							position++
						l242:
							{
								position243, tokenIndex243 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l243
								}
								goto l242
							l243:
								position, tokenIndex = position243, tokenIndex243
							}
							if buffer[position] != rune('"') {
								goto l229
							}
							position++
							add(rulePegText, position241)
						}
						{
							add(ruleAction15, position)
						}
						add(rulequotedKey, position240)
					}
				}
			l231:
				add(rulekey, position230)
			}
			return true
		l229:
			position, tokenIndex = position229, tokenIndex229
			return false
		},
		/* 13 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action14)> */
		nil,
		/* 14 quotedKey <- <(<('"' basicChar* '"')> Action15)> */
		nil,
		/* 15 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				if !_rules[ruletableKeyComp]() {
					goto l247
				}
			l249:
				{
					position250, tokenIndex250 := position, tokenIndex
					{
						position251 := position
						if !_rules[rulews]() {
							goto l250
						}
						if buffer[position] != rune('.') {
							goto l250
						}
						position++
						if !_rules[rulews]() {
							goto l250
						}
						add(ruletableKeySep, position251)
					}
					if !_rules[ruletableKeyComp]() {
						goto l250
					}
					goto l249
				l250:
					position, tokenIndex = position250, tokenIndex250
				}
				add(ruletableKey, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 16 tableKeyComp <- <(key Action16)> */
		func() bool {
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				if !_rules[rulekey]() {
					goto l252
				}
				{
					add(ruleAction16, position)
				}
				add(ruletableKeyComp, position253)
			}
			return true
		l252:
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 17 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 18 inlineTable <- <('{' Action17 ws inlineTableKeyValues? ws '}' Action18)> */
		nil,
		/* 19 inlineTableKeyValues <- <(keyval (ws inlineTableCommaRequired ws keyval)* ws inlineTableCommaForbidden)> */
		nil,
		/* 20 inlineTableCommaForbidden <- <(!',' / (',' Action19))> */
		nil,
		/* 21 inlineTableCommaRequired <- <((!',' Action20) / ',')> */
		nil,
		/* 22 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 23 integer <- <(hexInt / octalInt / binaryInt / decimalInt / (('+' / '-') decimalInt))> */
		nil,
		/* 24 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position262, tokenIndex262 := position, tokenIndex
			{
				position263 := position
				{
					position264, tokenIndex264 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l265
					}
					position++
					{
						position268, tokenIndex268 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l269
						}
						goto l268
					l269:
						position, tokenIndex = position268, tokenIndex268
						if buffer[position] != rune('_') {
							goto l265
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l265
						}
					}
				l268:
				l266:
					{
						position267, tokenIndex267 := position, tokenIndex
						{
							position270, tokenIndex270 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l271
							}
							goto l270
						l271:
							position, tokenIndex = position270, tokenIndex270
							if buffer[position] != rune('_') {
								goto l267
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l267
							}
						}
					l270:
						goto l266
					l267:
						position, tokenIndex = position267, tokenIndex267
					}
					goto l264
				l265:
					position, tokenIndex = position264, tokenIndex264
					if !_rules[ruledecimalDigit]() {
						goto l262
					}
				}
			l264:
				add(ruledecimalInt, position263)
			}
			return true
		l262:
			position, tokenIndex = position262, tokenIndex262
			return false
		},
		/* 25 decimalDigit <- <[0-9]> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l272
				}
				position++
				add(ruledecimalDigit, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 26 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 27 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l275
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l275
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l275
						}
						position++
					}
				}

				add(rulehexDigit, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 28 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 29 octalDigit <- <[0-7]> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l279
				}
				position++
				add(ruleoctalDigit, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 30 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 31 binaryDigit <- <('0' / '1')> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				{
					position284, tokenIndex284 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l285
					}
					position++
					goto l284
				l285:
					position, tokenIndex = position284, tokenIndex284
					if buffer[position] != rune('1') {
						goto l282
					}
					position++
				}
			l284:
				add(rulebinaryDigit, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 32 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 33 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 34 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position288, tokenIndex288 := position, tokenIndex
			{
				position289 := position
				if buffer[position] != rune('.') {
					goto l288
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l288
				}
			l290:
				{
					position291, tokenIndex291 := position, tokenIndex
					{
						position292, tokenIndex292 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l293
						}
						goto l292
					l293:
						position, tokenIndex = position292, tokenIndex292
						if buffer[position] != rune('_') {
							goto l291
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l291
						}
					}
				l292:
					goto l290
				l291:
					position, tokenIndex = position291, tokenIndex291
				}
				add(rulefloatFrac, position289)
			}
			return true
		l288:
			position, tokenIndex = position288, tokenIndex288
			return false
		},
		/* 35 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position294, tokenIndex294 := position, tokenIndex
			{
				position295 := position
				{
					position296, tokenIndex296 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l297
					}
					position++
					goto l296
				l297:
					position, tokenIndex = position296, tokenIndex296
					if buffer[position] != rune('E') {
						goto l294
					}
					position++
				}
			l296:
				{
					position298, tokenIndex298 := position, tokenIndex
					{
						position300, tokenIndex300 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l301
						}
						position++
						goto l300
					l301:
						position, tokenIndex = position300, tokenIndex300
						if buffer[position] != rune('+') {
							goto l298
						}
						position++
					}
				l300:
					goto l299
				l298:
					position, tokenIndex = position298, tokenIndex298
				}
			l299:
				if !_rules[ruledecimalDigit]() {
					goto l294
				}
			l302:
				{
					position303, tokenIndex303 := position, tokenIndex
					{
						position304, tokenIndex304 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l305
						}
						goto l304
					l305:
						position, tokenIndex = position304, tokenIndex304
						if buffer[position] != rune('_') {
							goto l303
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l303
						}
					}
				l304:
					goto l302
				l303:
					position, tokenIndex = position303, tokenIndex303
				}
				add(rulefloatExp, position295)
			}
			return true
		l294:
			position, tokenIndex = position294, tokenIndex294
			return false
		},
		/* 36 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 37 escape <- <'\\'> */
		func() bool {
			position307, tokenIndex307 := position, tokenIndex
			{
				position308 := position
				if buffer[position] != rune('\\') {
					goto l307
				}
				position++
				add(ruleescape, position308)
			}
			return true
		l307:
			position, tokenIndex = position307, tokenIndex307
			return false
		},
		/* 38 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position309, tokenIndex309 := position, tokenIndex
			{
				position310 := position
				if !_rules[rulehexDigit]() {
					goto l309
				}
				if !_rules[rulehexDigit]() {
					goto l309
				}
				if !_rules[rulehexDigit]() {
					goto l309
				}
				if !_rules[rulehexDigit]() {
					goto l309
				}
				add(rulehexQuad, position310)
			}
			return true
		l309:
			position, tokenIndex = position309, tokenIndex309
			return false
		},
		/* 39 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 40 basicString <- <(<('"' basicChar* '"')> Action21)> */
		nil,
		/* 41 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				{
					position315, tokenIndex315 := position, tokenIndex
					{
						position317 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l316
								}
								position++
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l316
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l316
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l316
								}
								position++
							}
						}

						add(rulebasicUnescaped, position317)
					}
					goto l315
				l316:
					position, tokenIndex = position315, tokenIndex315
					{
						position319 := position
						if !_rules[ruleescape]() {
							goto l313
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l313
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l313
								}
								if !_rules[rulehexQuad]() {
									goto l313
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l313
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l313
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l313
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l313
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l313
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l313
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l313
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l313
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l313
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l313
								}
								position++
							}
						}

						add(ruleescaped, position319)
					}
				}
			l315:
				add(rulebasicChar, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 42 basicUnescaped <- <((&('\t') '\t') | (&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') []-\U0010ffff]))> */
		nil,
		/* 43 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action22)> */
		nil,
		/* 44 mlBasicBody <- <((!('"' '"' '"') '"' Action23) / (<(basicChar / newline)> Action24) / (escape newline wsnl))*> */
		nil,
		/* 45 literalString <- <('\'' <literalChar*> '\'' Action25)> */
		nil,
		/* 46 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') [(-\U0010ffff]))> */
		nil,
		/* 47 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action26)> */
		nil,
		/* 48 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 49 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 50 datetime <- <((fullDate (((&(' ') ' ') | (&('t') 't') | (&('T') 'T')) fullTime)?) / partialTime)> */
		nil,
		/* 51 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				if !_rules[ruletimeHour]() {
					goto l330
				}
				if buffer[position] != rune(':') {
					goto l330
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l330
				}
				if buffer[position] != rune(':') {
					goto l330
				}
				position++
				{
					position332 := position
					if !_rules[ruledigitDual]() {
						goto l330
					}
					add(ruletimeSecond, position332)
				}
				{
					position333, tokenIndex333 := position, tokenIndex
					{
						position335 := position
						if buffer[position] != rune('.') {
							goto l333
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l333
						}
					l336:
						{
							position337, tokenIndex337 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l337
							}
							goto l336
						l337:
							position, tokenIndex = position337, tokenIndex337
						}
						add(ruletimeSecfrac, position335)
					}
					goto l334
				l333:
					position, tokenIndex = position333, tokenIndex333
				}
			l334:
				add(rulepartialTime, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 52 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 53 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 54 dateFullYear <- <digitQuad> */
		nil,
		/* 55 dateMonth <- <digitDual> */
		nil,
		/* 56 dateMDay <- <digitDual> */
		nil,
		/* 57 timeHour <- <digitDual> */
		func() bool {
			position343, tokenIndex343 := position, tokenIndex
			{
				position344 := position
				if !_rules[ruledigitDual]() {
					goto l343
				}
				add(ruletimeHour, position344)
			}
			return true
		l343:
			position, tokenIndex = position343, tokenIndex343
			return false
		},
		/* 58 timeMinute <- <digitDual> */
		func() bool {
			position345, tokenIndex345 := position, tokenIndex
			{
				position346 := position
				if !_rules[ruledigitDual]() {
					goto l345
				}
				add(ruletimeMinute, position346)
			}
			return true
		l345:
			position, tokenIndex = position345, tokenIndex345
			return false
		},
		/* 59 timeSecond <- <digitDual> */
		nil,
		/* 60 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 61 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 62 timeOffset <- <((&('z') 'z') | (&('Z') 'Z') | (&('+' | '-') timeNumoffset))> */
		nil,
		/* 63 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position351, tokenIndex351 := position, tokenIndex
			{
				position352 := position
				if !_rules[ruledecimalDigit]() {
					goto l351
				}
				if !_rules[ruledecimalDigit]() {
					goto l351
				}
				add(ruledigitDual, position352)
			}
			return true
		l351:
			position, tokenIndex = position351, tokenIndex351
			return false
		},
		/* 64 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 65 array <- <('[' Action27 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 66 arrayValues <- <((wsnl comment)* wsnl val Action28 ((wsnl comment)* wsnl arraySep (wsnl comment)* wsnl val Action29)* (wsnl comment)* wsnl arraySep? (wsnl comment)*)> */
		nil,
		/* 67 arraySep <- <','> */
		func() bool {
			position356, tokenIndex356 := position, tokenIndex
			{
				position357 := position
				if buffer[position] != rune(',') {
					goto l356
				}
				position++
				add(rulearraySep, position357)
			}
			return true
		l356:
			position, tokenIndex = position356, tokenIndex356
			return false
		},
		/* 69 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 71 Action1 <- <{ p.SetTableSource(begin, end) }> */
		nil,
		/* 72 Action2 <- <{ p.Newline() }> */
		nil,
		/* 73 Action3 <- <{ p.Error(errNewlineRequired) }> */
		nil,
		/* 74 Action4 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 75 Action5 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 76 Action6 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 77 Action7 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 78 Action8 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 79 Action9 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 80 Action10 <- <{ p.SetInlineTableSource(begin, end) }> */
		nil,
		/* 81 Action11 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 82 Action12 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 83 Action13 <- <{ p.AddKeyValue() }> */
		nil,
		/* 84 Action14 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 85 Action15 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 86 Action16 <- <{ p.AddTableKey() }> */
		nil,
		/* 87 Action17 <- <{ p.StartInlineTable() }> */
		nil,
		/* 88 Action18 <- <{ p.EndInlineTable() }> */
		nil,
		/* 89 Action19 <- <{ p.Error(errInlineTableCommaAtEnd) }> */
		nil,
		/* 90 Action20 <- <{ p.Error(errInlineTableCommaRequired) }> */
		nil,
		/* 91 Action21 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 92 Action22 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 93 Action23 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 94 Action24 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 95 Action25 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 96 Action26 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 97 Action27 <- <{ p.StartArray() }> */
		nil,
		/* 98 Action28 <- <{ p.AddArrayVal() }> */
		nil,
		/* 99 Action29 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
