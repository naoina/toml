package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleescaped
	ruleescape
	rulehexDigit
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruleboolean
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruleinteger
	ruleint
	rulefloat
	rulefrac
	ruleexp
	ruledigit
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"escaped",
	"escape",
	"hexDigit",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"boolean",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"integer",
	"int",
	"float",
	"frac",
	"exp",
	"digit",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [89]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.AddLineCount(end - begin)
		case ruleAction3:
			p.AddLineCount(end - begin)
		case ruleAction4:
			p.AddKeyValue()
		case ruleAction5:
			p.SetKey(p.buffer, begin, end)
		case ruleAction6:
			p.SetKey(p.buffer, begin, end)
		case ruleAction7:
			p.SetTime(begin, end)
		case ruleAction8:
			p.SetFloat64(begin, end)
		case ruleAction9:
			p.SetInt64(begin, end)
		case ruleAction10:
			p.SetString(begin, end)
		case ruleAction11:
			p.SetBool(begin, end)
		case ruleAction12:
			p.SetArray(begin, end)
		case ruleAction13:
			p.SetTable(p.buffer, begin, end)
		case ruleAction14:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction15:
			p.StartInlineTable()
		case ruleAction16:
			p.EndInlineTable()
		case ruleAction17:
			p.AddTableKey()
		case ruleAction18:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction19:
			p.SetMultilineBasicString()
		case ruleAction20:
			p.AddMultilineBasicQuote()
		case ruleAction21:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction22:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction24:
			p.StartArray()
		case ruleAction25:
			p.AddArrayVal()
		case ruleAction26:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline? !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l4
					}
					goto l5
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction14, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <(<('\r' / '\n')+> Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37 := position
					{
						position40, tokenIndex40 := position, tokenIndex
						if buffer[position] != rune('\r') {
							goto l41
						}
						position++
						goto l40
					l41:
						position, tokenIndex = position40, tokenIndex40
						if buffer[position] != rune('\n') {
							goto l35
						}
						position++
					}
				l40:
				l38:
					{
						position39, tokenIndex39 := position, tokenIndex
						{
							position42, tokenIndex42 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l43
							}
							position++
							goto l42
						l43:
							position, tokenIndex = position42, tokenIndex42
							if buffer[position] != rune('\n') {
								goto l39
							}
							position++
						}
					l42:
						goto l38
					l39:
						position, tokenIndex = position39, tokenIndex39
					}
					add(rulePegText, position37)
				}
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position46 := position
			l47:
				{
					position48, tokenIndex48 := position, tokenIndex
					{
						position49, tokenIndex49 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l50
						}
						position++
						goto l49
					l50:
						position, tokenIndex = position49, tokenIndex49
						if buffer[position] != rune('\t') {
							goto l48
						}
						position++
					}
				l49:
					goto l47
				l48:
					position, tokenIndex = position48, tokenIndex48
				}
				add(rulews, position46)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') (<('\r' / '\n')> Action3)))*> */
		func() bool {
			{
				position52 := position
			l53:
				{
					position54, tokenIndex54 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l54
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l54
							}
							position++
						default:
							{
								position56 := position
								{
									position57, tokenIndex57 := position, tokenIndex
									if buffer[position] != rune('\r') {
										goto l58
									}
									position++
									goto l57
								l58:
									position, tokenIndex = position57, tokenIndex57
									if buffer[position] != rune('\n') {
										goto l54
									}
									position++
								}
							l57:
								add(rulePegText, position56)
							}
							{
								add(ruleAction3, position)
							}
						}
					}

					goto l53
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
				add(rulewsnl, position52)
			}
			return true
		},
		/* 5 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if buffer[position] != rune('#') {
					goto l60
				}
				position++
				{
					position62 := position
				l63:
					{
						position64, tokenIndex64 := position, tokenIndex
						{
							position65, tokenIndex65 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l66
							}
							position++
							goto l65
						l66:
							position, tokenIndex = position65, tokenIndex65
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l64
							}
							position++
						}
					l65:
						goto l63
					l64:
						position, tokenIndex = position64, tokenIndex64
					}
					add(rulePegText, position62)
				}
				add(rulecomment, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 6 keyval <- <(key ws '=' ws val Action4)> */
		func() bool {
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				if !_rules[rulekey]() {
					goto l67
				}
				if !_rules[rulews]() {
					goto l67
				}
				if buffer[position] != rune('=') {
					goto l67
				}
				position++
				if !_rules[rulews]() {
					goto l67
				}
				if !_rules[ruleval]() {
					goto l67
				}
				{
					add(ruleAction4, position)
				}
				add(rulekeyval, position68)
			}
			return true
		l67:
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 7 key <- <(bareKey / quotedKey)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				{
					position72, tokenIndex72 := position, tokenIndex
					{
						position74 := position
						{
							position75 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l73
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l73
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l73
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l73
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l73
									}
									position++
								}
							}

						l76:
							{
								position77, tokenIndex77 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l77
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l77
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l77
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l77
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l77
										}
										position++
									}
								}

								goto l76
							l77:
								position, tokenIndex = position77, tokenIndex77
							}
							add(rulePegText, position75)
						}
						{
							add(ruleAction5, position)
						}
						add(rulebareKey, position74)
					}
					goto l72
				l73:
					position, tokenIndex = position72, tokenIndex72
					{
						position81 := position
						{
							position82 := position
							if buffer[position] != rune('"') {
								goto l70
							}
							position++
						l83:
							{
								position84, tokenIndex84 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l84
								}
								goto l83
							l84:
								position, tokenIndex = position84, tokenIndex84
							}
							if buffer[position] != rune('"') {
								goto l70
							}
							position++
							add(rulePegText, position82)
						}
						{
							add(ruleAction6, position)
						}
						add(rulequotedKey, position81)
					}
				}
			l72:
				add(rulekey, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 8 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action5)> */
		nil,
		/* 9 quotedKey <- <(<('"' basicChar* '"')> Action6)> */
		nil,
		/* 10 val <- <((<datetime> Action7) / (<float> Action8) / ((&('{') inlineTable) | (&('[') (<array> Action12)) | (&('f' | 't') (<boolean> Action11)) | (&('"' | '\'') (<string> Action10)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action9))))> */
		func() bool {
			position88, tokenIndex88 := position, tokenIndex
			{
				position89 := position
				{
					position90, tokenIndex90 := position, tokenIndex
					{
						position92 := position
						{
							position93 := position
							{
								position94, tokenIndex94 := position, tokenIndex
								{
									position96 := position
									{
										position97 := position
										{
											position98 := position
											if !_rules[ruledigitDual]() {
												goto l95
											}
											if !_rules[ruledigitDual]() {
												goto l95
											}
											add(ruledigitQuad, position98)
										}
										add(ruledateFullYear, position97)
									}
									if buffer[position] != rune('-') {
										goto l95
									}
									position++
									{
										position99 := position
										if !_rules[ruledigitDual]() {
											goto l95
										}
										add(ruledateMonth, position99)
									}
									if buffer[position] != rune('-') {
										goto l95
									}
									position++
									{
										position100 := position
										if !_rules[ruledigitDual]() {
											goto l95
										}
										add(ruledateMDay, position100)
									}
									add(rulefullDate, position96)
								}
								{
									position101, tokenIndex101 := position, tokenIndex
									if buffer[position] != rune('T') {
										goto l101
									}
									position++
									{
										position103 := position
										if !_rules[rulepartialTime]() {
											goto l101
										}
										{
											position104, tokenIndex104 := position, tokenIndex
											{
												position106 := position
												{
													position107, tokenIndex107 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l108
													}
													position++
													goto l107
												l108:
													position, tokenIndex = position107, tokenIndex107
													{
														position109 := position
														{
															position110, tokenIndex110 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l111
															}
															position++
															goto l110
														l111:
															position, tokenIndex = position110, tokenIndex110
															if buffer[position] != rune('+') {
																goto l104
															}
															position++
														}
													l110:
														if !_rules[ruletimeHour]() {
															goto l104
														}
														if buffer[position] != rune(':') {
															goto l104
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l104
														}
														add(ruletimeNumoffset, position109)
													}
												}
											l107:
												add(ruletimeOffset, position106)
											}
											goto l105
										l104:
											position, tokenIndex = position104, tokenIndex104
										}
									l105:
										add(rulefullTime, position103)
									}
									goto l102
								l101:
									position, tokenIndex = position101, tokenIndex101
								}
							l102:
								goto l94
							l95:
								position, tokenIndex = position94, tokenIndex94
								if !_rules[rulepartialTime]() {
									goto l91
								}
							}
						l94:
							add(ruledatetime, position93)
						}
						add(rulePegText, position92)
					}
					{
						add(ruleAction7, position)
					}
					goto l90
				l91:
					position, tokenIndex = position90, tokenIndex90
					{
						position114 := position
						{
							position115 := position
							if !_rules[ruleinteger]() {
								goto l113
							}
							{
								position116, tokenIndex116 := position, tokenIndex
								if !_rules[rulefrac]() {
									goto l117
								}
								{
									position118, tokenIndex118 := position, tokenIndex
									if !_rules[ruleexp]() {
										goto l118
									}
									goto l119
								l118:
									position, tokenIndex = position118, tokenIndex118
								}
							l119:
								goto l116
							l117:
								position, tokenIndex = position116, tokenIndex116
								{
									position120, tokenIndex120 := position, tokenIndex
									if !_rules[rulefrac]() {
										goto l120
									}
									goto l121
								l120:
									position, tokenIndex = position120, tokenIndex120
								}
							l121:
								if !_rules[ruleexp]() {
									goto l113
								}
							}
						l116:
							add(rulefloat, position115)
						}
						add(rulePegText, position114)
					}
					{
						add(ruleAction8, position)
					}
					goto l90
				l113:
					position, tokenIndex = position90, tokenIndex90
					{
						switch buffer[position] {
						case '{':
							{
								position124 := position
								if buffer[position] != rune('{') {
									goto l88
								}
								position++
								{
									add(ruleAction15, position)
								}
								if !_rules[rulews]() {
									goto l88
								}
								{
									position126 := position
								l127:
									{
										position128, tokenIndex128 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l128
										}
										{
											position129, tokenIndex129 := position, tokenIndex
											{
												position131 := position
												if !_rules[rulews]() {
													goto l129
												}
												if buffer[position] != rune(',') {
													goto l129
												}
												position++
												if !_rules[rulews]() {
													goto l129
												}
												add(ruleinlineTableValSep, position131)
											}
											goto l130
										l129:
											position, tokenIndex = position129, tokenIndex129
										}
									l130:
										goto l127
									l128:
										position, tokenIndex = position128, tokenIndex128
									}
									add(ruleinlineTableKeyValues, position126)
								}
								if !_rules[rulews]() {
									goto l88
								}
								if buffer[position] != rune('}') {
									goto l88
								}
								position++
								{
									add(ruleAction16, position)
								}
								add(ruleinlineTable, position124)
							}
						case '[':
							{
								position133 := position
								{
									position134 := position
									if buffer[position] != rune('[') {
										goto l88
									}
									position++
									{
										add(ruleAction24, position)
									}
									if !_rules[rulewsnl]() {
										goto l88
									}
									{
										position136, tokenIndex136 := position, tokenIndex
										{
											position138 := position
											if !_rules[ruleval]() {
												goto l136
											}
											{
												add(ruleAction25, position)
											}
										l140:
											{
												position141, tokenIndex141 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l141
												}
												{
													position142, tokenIndex142 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l142
													}
													goto l143
												l142:
													position, tokenIndex = position142, tokenIndex142
												}
											l143:
												if !_rules[rulewsnl]() {
													goto l141
												}
												if !_rules[rulearraySep]() {
													goto l141
												}
												if !_rules[rulewsnl]() {
													goto l141
												}
												{
													position144, tokenIndex144 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l144
													}
													goto l145
												l144:
													position, tokenIndex = position144, tokenIndex144
												}
											l145:
												if !_rules[rulewsnl]() {
													goto l141
												}
												if !_rules[ruleval]() {
													goto l141
												}
												{
													add(ruleAction26, position)
												}
												goto l140
											l141:
												position, tokenIndex = position141, tokenIndex141
											}
											if !_rules[rulewsnl]() {
												goto l136
											}
											{
												position147, tokenIndex147 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l147
												}
												goto l148
											l147:
												position, tokenIndex = position147, tokenIndex147
											}
										l148:
											if !_rules[rulewsnl]() {
												goto l136
											}
											{
												position149, tokenIndex149 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l149
												}
												goto l150
											l149:
												position, tokenIndex = position149, tokenIndex149
											}
										l150:
											add(rulearrayValues, position138)
										}
										goto l137
									l136:
										position, tokenIndex = position136, tokenIndex136
									}
								l137:
									if !_rules[rulewsnl]() {
										goto l88
									}
									if buffer[position] != rune(']') {
										goto l88
									}
									position++
									add(rulearray, position134)
								}
								add(rulePegText, position133)
							}
							{
								add(ruleAction12, position)
							}
						case 'f', 't':
							{
								position152 := position
								{
									position153 := position
									{
										position154, tokenIndex154 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l155
										}
										position++
										if buffer[position] != rune('r') {
											goto l155
										}
										position++
										if buffer[position] != rune('u') {
											goto l155
										}
										position++
										if buffer[position] != rune('e') {
											goto l155
										}
										position++
										goto l154
									l155:
										position, tokenIndex = position154, tokenIndex154
										if buffer[position] != rune('f') {
											goto l88
										}
										position++
										if buffer[position] != rune('a') {
											goto l88
										}
										position++
										if buffer[position] != rune('l') {
											goto l88
										}
										position++
										if buffer[position] != rune('s') {
											goto l88
										}
										position++
										if buffer[position] != rune('e') {
											goto l88
										}
										position++
									}
								l154:
									add(ruleboolean, position153)
								}
								add(rulePegText, position152)
							}
							{
								add(ruleAction11, position)
							}
						case '"', '\'':
							{
								position157 := position
								{
									position158 := position
									{
										position159, tokenIndex159 := position, tokenIndex
										{
											position161 := position
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											{
												position162 := position
												{
													position163 := position
												l164:
													{
														position165, tokenIndex165 := position, tokenIndex
														{
															position166, tokenIndex166 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l166
															}
															position++
															if buffer[position] != rune('\'') {
																goto l166
															}
															position++
															if buffer[position] != rune('\'') {
																goto l166
															}
															position++
															goto l165
														l166:
															position, tokenIndex = position166, tokenIndex166
														}
														{
															position167, tokenIndex167 := position, tokenIndex
															{
																position169 := position
																{
																	position170, tokenIndex170 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l171
																	}
																	position++
																	goto l170
																l171:
																	position, tokenIndex = position170, tokenIndex170
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l168
																	}
																	position++
																}
															l170:
																add(rulemlLiteralChar, position169)
															}
															goto l167
														l168:
															position, tokenIndex = position167, tokenIndex167
															if !_rules[rulenewline]() {
																goto l165
															}
														}
													l167:
														goto l164
													l165:
														position, tokenIndex = position165, tokenIndex165
													}
													add(rulemlLiteralBody, position163)
												}
												add(rulePegText, position162)
											}
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											if buffer[position] != rune('\'') {
												goto l160
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlLiteralString, position161)
										}
										goto l159
									l160:
										position, tokenIndex = position159, tokenIndex159
										{
											position174 := position
											if buffer[position] != rune('\'') {
												goto l173
											}
											position++
											{
												position175 := position
											l176:
												{
													position177, tokenIndex177 := position, tokenIndex
													{
														position178 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l177
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l177
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l177
																}
																position++
															}
														}

														add(ruleliteralChar, position178)
													}
													goto l176
												l177:
													position, tokenIndex = position177, tokenIndex177
												}
												add(rulePegText, position175)
											}
											if buffer[position] != rune('\'') {
												goto l173
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(ruleliteralString, position174)
										}
										goto l159
									l173:
										position, tokenIndex = position159, tokenIndex159
										{
											position182 := position
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											{
												position183 := position
											l184:
												{
													position185, tokenIndex185 := position, tokenIndex
													{
														position186, tokenIndex186 := position, tokenIndex
														{
															position188, tokenIndex188 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l188
															}
															position++
															if buffer[position] != rune('"') {
																goto l188
															}
															position++
															if buffer[position] != rune('"') {
																goto l188
															}
															position++
															goto l187
														l188:
															position, tokenIndex = position188, tokenIndex188
														}
														if buffer[position] != rune('"') {
															goto l187
														}
														position++
														{
															add(ruleAction20, position)
														}
														goto l186
													l187:
														position, tokenIndex = position186, tokenIndex186
														{
															position191 := position
															{
																position192, tokenIndex192 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l193
																}
																goto l192
															l193:
																position, tokenIndex = position192, tokenIndex192
																if !_rules[rulenewline]() {
																	goto l190
																}
															}
														l192:
															add(rulePegText, position191)
														}
														{
															add(ruleAction21, position)
														}
														goto l186
													l190:
														position, tokenIndex = position186, tokenIndex186
														if !_rules[ruleescape]() {
															goto l185
														}
														if !_rules[rulenewline]() {
															goto l185
														}
														if !_rules[rulewsnl]() {
															goto l185
														}
													}
												l186:
													goto l184
												l185:
													position, tokenIndex = position185, tokenIndex185
												}
												add(rulemlBasicBody, position183)
											}
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											if buffer[position] != rune('"') {
												goto l181
											}
											position++
											{
												add(ruleAction19, position)
											}
											add(rulemlBasicString, position182)
										}
										goto l159
									l181:
										position, tokenIndex = position159, tokenIndex159
										{
											position196 := position
											{
												position197 := position
												if buffer[position] != rune('"') {
													goto l88
												}
												position++
											l198:
												{
													position199, tokenIndex199 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l199
													}
													goto l198
												l199:
													position, tokenIndex = position199, tokenIndex199
												}
												if buffer[position] != rune('"') {
													goto l88
												}
												position++
												add(rulePegText, position197)
											}
											{
												add(ruleAction18, position)
											}
											add(rulebasicString, position196)
										}
									}
								l159:
									add(rulestring, position158)
								}
								add(rulePegText, position157)
							}
							{
								add(ruleAction10, position)
							}
						default:
							{
								position202 := position
								if !_rules[ruleinteger]() {
									goto l88
								}
								add(rulePegText, position202)
							}
							{
								add(ruleAction9, position)
							}
						}
					}

				}
			l90:
				add(ruleval, position89)
			}
			return true
		l88:
			position, tokenIndex = position88, tokenIndex88
			return false
		},
		/* 11 table <- <(stdTable / arrayTable)> */
		nil,
		/* 12 stdTable <- <('[' ws <tableKey> ws ']' Action13)> */
		nil,
		/* 13 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action14)> */
		nil,
		/* 14 inlineTable <- <('{' Action15 ws inlineTableKeyValues ws '}' Action16)> */
		nil,
		/* 15 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if !_rules[ruletableKeyComp]() {
					goto l209
				}
			l211:
				{
					position212, tokenIndex212 := position, tokenIndex
					{
						position213 := position
						if !_rules[rulews]() {
							goto l212
						}
						if buffer[position] != rune('.') {
							goto l212
						}
						position++
						if !_rules[rulews]() {
							goto l212
						}
						add(ruletableKeySep, position213)
					}
					if !_rules[ruletableKeyComp]() {
						goto l212
					}
					goto l211
				l212:
					position, tokenIndex = position212, tokenIndex212
				}
				add(ruletableKey, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 17 tableKeyComp <- <(key Action17)> */
		func() bool {
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				if !_rules[rulekey]() {
					goto l214
				}
				{
					add(ruleAction17, position)
				}
				add(ruletableKeyComp, position215)
			}
			return true
		l214:
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 21 escape <- <'\\'> */
		func() bool {
			position220, tokenIndex220 := position, tokenIndex
			{
				position221 := position
				if buffer[position] != rune('\\') {
					goto l220
				}
				position++
				add(ruleescape, position221)
			}
			return true
		l220:
			position, tokenIndex = position220, tokenIndex220
			return false
		},
		/* 22 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position222, tokenIndex222 := position, tokenIndex
			{
				position223 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l222
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l222
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l222
						}
						position++
					}
				}

				add(rulehexDigit, position223)
			}
			return true
		l222:
			position, tokenIndex = position222, tokenIndex222
			return false
		},
		/* 23 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				if !_rules[rulehexDigit]() {
					goto l225
				}
				if !_rules[rulehexDigit]() {
					goto l225
				}
				if !_rules[rulehexDigit]() {
					goto l225
				}
				if !_rules[rulehexDigit]() {
					goto l225
				}
				add(rulehexQuad, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 24 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 25 basicString <- <(<('"' basicChar* '"')> Action18)> */
		nil,
		/* 26 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position229, tokenIndex229 := position, tokenIndex
			{
				position230 := position
				{
					position231, tokenIndex231 := position, tokenIndex
					{
						position233 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l232
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l232
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l232
								}
								position++
							}
						}

						add(rulebasicUnescaped, position233)
					}
					goto l231
				l232:
					position, tokenIndex = position231, tokenIndex231
					{
						position235 := position
						if !_rules[ruleescape]() {
							goto l229
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l229
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l229
								}
								if !_rules[rulehexQuad]() {
									goto l229
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l229
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l229
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l229
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l229
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l229
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l229
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l229
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l229
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l229
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l229
								}
								position++
							}
						}

						add(ruleescaped, position235)
					}
				}
			l231:
				add(rulebasicChar, position230)
			}
			return true
		l229:
			position, tokenIndex = position229, tokenIndex229
			return false
		},
		/* 27 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') []-\U0010ffff]))> */
		nil,
		/* 28 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action19)> */
		nil,
		/* 29 mlBasicBody <- <((!('"' '"' '"') '"' Action20) / (<(basicChar / newline)> Action21) / (escape newline wsnl))*> */
		nil,
		/* 30 literalString <- <('\'' <literalChar*> '\'' Action22)> */
		nil,
		/* 31 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') [(-\U0010ffff]))> */
		nil,
		/* 32 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action23)> */
		nil,
		/* 33 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 34 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 35 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 36 dateFullYear <- <digitQuad> */
		nil,
		/* 37 dateMonth <- <digitDual> */
		nil,
		/* 38 dateMDay <- <digitDual> */
		nil,
		/* 39 timeHour <- <digitDual> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				if !_rules[ruledigitDual]() {
					goto l249
				}
				add(ruletimeHour, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 40 timeMinute <- <digitDual> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				if !_rules[ruledigitDual]() {
					goto l251
				}
				add(ruletimeMinute, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 41 timeSecond <- <digitDual> */
		nil,
		/* 42 timeSecfrac <- <('.' digit+)> */
		nil,
		/* 43 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 44 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 45 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position257, tokenIndex257 := position, tokenIndex
			{
				position258 := position
				if !_rules[ruletimeHour]() {
					goto l257
				}
				if buffer[position] != rune(':') {
					goto l257
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l257
				}
				if buffer[position] != rune(':') {
					goto l257
				}
				position++
				{
					position259 := position
					if !_rules[ruledigitDual]() {
						goto l257
					}
					add(ruletimeSecond, position259)
				}
				{
					position260, tokenIndex260 := position, tokenIndex
					{
						position262 := position
						if buffer[position] != rune('.') {
							goto l260
						}
						position++
						if !_rules[ruledigit]() {
							goto l260
						}
					l263:
						{
							position264, tokenIndex264 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l264
							}
							goto l263
						l264:
							position, tokenIndex = position264, tokenIndex264
						}
						add(ruletimeSecfrac, position262)
					}
					goto l261
				l260:
					position, tokenIndex = position260, tokenIndex260
				}
			l261:
				add(rulepartialTime, position258)
			}
			return true
		l257:
			position, tokenIndex = position257, tokenIndex257
			return false
		},
		/* 46 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 47 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 48 datetime <- <((fullDate ('T' fullTime)?) / partialTime)> */
		nil,
		/* 49 integer <- <(('-' / '+')? int)> */
		func() bool {
			position268, tokenIndex268 := position, tokenIndex
			{
				position269 := position
				{
					position270, tokenIndex270 := position, tokenIndex
					{
						position272, tokenIndex272 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l273
						}
						position++
						goto l272
					l273:
						position, tokenIndex = position272, tokenIndex272
						if buffer[position] != rune('+') {
							goto l270
						}
						position++
					}
				l272:
					goto l271
				l270:
					position, tokenIndex = position270, tokenIndex270
				}
			l271:
				{
					position274 := position
					{
						position275, tokenIndex275 := position, tokenIndex
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l276
						}
						position++
						{
							position279, tokenIndex279 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l280
							}
							goto l279
						l280:
							position, tokenIndex = position279, tokenIndex279
							if buffer[position] != rune('_') {
								goto l276
							}
							position++
							if !_rules[ruledigit]() {
								goto l276
							}
						}
					l279:
					l277:
						{
							position278, tokenIndex278 := position, tokenIndex
							{
								position281, tokenIndex281 := position, tokenIndex
								if !_rules[ruledigit]() {
									goto l282
								}
								goto l281
							l282:
								position, tokenIndex = position281, tokenIndex281
								if buffer[position] != rune('_') {
									goto l278
								}
								position++
								if !_rules[ruledigit]() {
									goto l278
								}
							}
						l281:
							goto l277
						l278:
							position, tokenIndex = position278, tokenIndex278
						}
						goto l275
					l276:
						position, tokenIndex = position275, tokenIndex275
						if !_rules[ruledigit]() {
							goto l268
						}
					}
				l275:
					add(ruleint, position274)
				}
				add(ruleinteger, position269)
			}
			return true
		l268:
			position, tokenIndex = position268, tokenIndex268
			return false
		},
		/* 50 int <- <(([1-9] (digit / ('_' digit))+) / digit)> */
		nil,
		/* 51 float <- <(integer ((frac exp?) / (frac? exp)))> */
		nil,
		/* 52 frac <- <('.' digit (digit / ('_' digit))*)> */
		func() bool {
			position285, tokenIndex285 := position, tokenIndex
			{
				position286 := position
				if buffer[position] != rune('.') {
					goto l285
				}
				position++
				if !_rules[ruledigit]() {
					goto l285
				}
			l287:
				{
					position288, tokenIndex288 := position, tokenIndex
					{
						position289, tokenIndex289 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l290
						}
						goto l289
					l290:
						position, tokenIndex = position289, tokenIndex289
						if buffer[position] != rune('_') {
							goto l288
						}
						position++
						if !_rules[ruledigit]() {
							goto l288
						}
					}
				l289:
					goto l287
				l288:
					position, tokenIndex = position288, tokenIndex288
				}
				add(rulefrac, position286)
			}
			return true
		l285:
			position, tokenIndex = position285, tokenIndex285
			return false
		},
		/* 53 exp <- <(('e' / 'E') ('-' / '+')? digit (digit / ('_' digit))*)> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				{
					position293, tokenIndex293 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l294
					}
					position++
					goto l293
				l294:
					position, tokenIndex = position293, tokenIndex293
					if buffer[position] != rune('E') {
						goto l291
					}
					position++
				}
			l293:
				{
					position295, tokenIndex295 := position, tokenIndex
					{
						position297, tokenIndex297 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l298
						}
						position++
						goto l297
					l298:
						position, tokenIndex = position297, tokenIndex297
						if buffer[position] != rune('+') {
							goto l295
						}
						position++
					}
				l297:
					goto l296
				l295:
					position, tokenIndex = position295, tokenIndex295
				}
			l296:
				if !_rules[ruledigit]() {
					goto l291
				}
			l299:
				{
					position300, tokenIndex300 := position, tokenIndex
					{
						position301, tokenIndex301 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l302
						}
						goto l301
					l302:
						position, tokenIndex = position301, tokenIndex301
						if buffer[position] != rune('_') {
							goto l300
						}
						position++
						if !_rules[ruledigit]() {
							goto l300
						}
					}
				l301:
					goto l299
				l300:
					position, tokenIndex = position300, tokenIndex300
				}
				add(ruleexp, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 54 digit <- <[0-9]> */
		func() bool {
			position303, tokenIndex303 := position, tokenIndex
			{
				position304 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l303
				}
				position++
				add(ruledigit, position304)
			}
			return true
		l303:
			position, tokenIndex = position303, tokenIndex303
			return false
		},
		/* 55 digitDual <- <(digit digit)> */
		func() bool {
			position305, tokenIndex305 := position, tokenIndex
			{
				position306 := position
				if !_rules[ruledigit]() {
					goto l305
				}
				if !_rules[ruledigit]() {
					goto l305
				}
				add(ruledigitDual, position306)
			}
			return true
		l305:
			position, tokenIndex = position305, tokenIndex305
			return false
		},
		/* 56 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 57 array <- <('[' Action24 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 58 arrayValues <- <(val Action25 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action26)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 59 arraySep <- <','> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if buffer[position] != rune(',') {
					goto l310
				}
				position++
				add(rulearraySep, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 61 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 63 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 64 Action2 <- <{ p.AddLineCount(end - begin) }> */
		nil,
		/* 65 Action3 <- <{ p.AddLineCount(end - begin) }> */
		nil,
		/* 66 Action4 <- <{ p.AddKeyValue() }> */
		nil,
		/* 67 Action5 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 68 Action6 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 69 Action7 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 70 Action8 <- <{ p.SetFloat64(begin, end) }> */
		nil,
		/* 71 Action9 <- <{ p.SetInt64(begin, end) }> */
		nil,
		/* 72 Action10 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 73 Action11 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 74 Action12 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 75 Action13 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 76 Action14 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 77 Action15 <- <{ p.StartInlineTable() }> */
		nil,
		/* 78 Action16 <- <{ p.EndInlineTable() }> */
		nil,
		/* 79 Action17 <- <{ p.AddTableKey() }> */
		nil,
		/* 80 Action18 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 81 Action19 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 82 Action20 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 83 Action21 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 84 Action22 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 85 Action23 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 86 Action24 <- <{ p.StartArray() }> */
		nil,
		/* 87 Action25 <- <{ p.AddArrayVal() }> */
		nil,
		/* 88 Action26 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
