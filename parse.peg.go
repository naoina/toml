package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulews
	rulewsnl
	rulecomment
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleboolean
	ruleinteger
	ruleanyInt
	ruledecimalInt
	ruledecimalDigit
	rulehexInt
	rulehexDigit
	ruleoctalInt
	ruleoctalDigit
	rulebinaryInt
	rulebinaryDigit
	rulefloat
	rulefloatDigits
	rulefloatFrac
	rulefloatExp
	ruleescaped
	ruleescape
	rulehexQuad
	rulestring
	rulebasicString
	rulebasicChar
	rulebasicUnescaped
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"ws",
	"wsnl",
	"comment",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"boolean",
	"integer",
	"anyInt",
	"decimalInt",
	"decimalDigit",
	"hexInt",
	"hexDigit",
	"octalInt",
	"octalDigit",
	"binaryInt",
	"binaryDigit",
	"float",
	"floatDigits",
	"floatFrac",
	"floatExp",
	"escaped",
	"escape",
	"hexQuad",
	"string",
	"basicString",
	"basicChar",
	"basicUnescaped",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [95]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.Newline()
		case ruleAction3:
			p.AddKeyValue()
		case ruleAction4:
			p.SetKey(p.buffer, begin, end)
		case ruleAction5:
			p.SetKey(p.buffer, begin, end)
		case ruleAction6:
			p.SetTime(begin, end)
		case ruleAction7:
			p.SetFloat(begin, end)
		case ruleAction8:
			p.SetInteger(begin, end)
		case ruleAction9:
			p.SetString(begin, end)
		case ruleAction10:
			p.SetBool(begin, end)
		case ruleAction11:
			p.SetArray(begin, end)
		case ruleAction12:
			p.SetTable(p.buffer, begin, end)
		case ruleAction13:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction14:
			p.StartInlineTable()
		case ruleAction15:
			p.EndInlineTable()
		case ruleAction16:
			p.AddTableKey()
		case ruleAction17:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction18:
			p.SetMultilineBasicString()
		case ruleAction19:
			p.AddMultilineBasicQuote()
		case ruleAction20:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction21:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction22:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.StartArray()
		case ruleAction24:
			p.AddArrayVal()
		case ruleAction25:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* newline* !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction12, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction13, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <((('\r' '\n') / '\n') Action2)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l38
					}
					position++
					if buffer[position] != rune('\n') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('\n') {
						goto l35
					}
					position++
				}
			l37:
				{
					add(ruleAction2, position)
				}
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position41 := position
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44, tokenIndex44 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l45
						}
						position++
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if buffer[position] != rune('\t') {
							goto l43
						}
						position++
					}
				l44:
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				add(rulews, position41)
			}
			return true
		},
		/* 4 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') newline))*> */
		func() bool {
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l49
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l49
							}
							position++
						default:
							if !_rules[rulenewline]() {
								goto l49
							}
						}
					}

					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(rulewsnl, position47)
			}
			return true
		},
		/* 5 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if buffer[position] != rune('#') {
					goto l51
				}
				position++
				{
					position53 := position
				l54:
					{
						position55, tokenIndex55 := position, tokenIndex
						{
							position56, tokenIndex56 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l57
							}
							position++
							goto l56
						l57:
							position, tokenIndex = position56, tokenIndex56
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l55
							}
							position++
						}
					l56:
						goto l54
					l55:
						position, tokenIndex = position55, tokenIndex55
					}
					add(rulePegText, position53)
				}
				add(rulecomment, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 6 keyval <- <(key ws '=' ws val Action3)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				if !_rules[rulekey]() {
					goto l58
				}
				if !_rules[rulews]() {
					goto l58
				}
				if buffer[position] != rune('=') {
					goto l58
				}
				position++
				if !_rules[rulews]() {
					goto l58
				}
				if !_rules[ruleval]() {
					goto l58
				}
				{
					add(ruleAction3, position)
				}
				add(rulekeyval, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 7 key <- <(bareKey / quotedKey)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				{
					position63, tokenIndex63 := position, tokenIndex
					{
						position65 := position
						{
							position66 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l64
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l64
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l64
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l64
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l64
									}
									position++
								}
							}

						l67:
							{
								position68, tokenIndex68 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l68
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l68
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l68
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l68
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l68
										}
										position++
									}
								}

								goto l67
							l68:
								position, tokenIndex = position68, tokenIndex68
							}
							add(rulePegText, position66)
						}
						{
							add(ruleAction4, position)
						}
						add(rulebareKey, position65)
					}
					goto l63
				l64:
					position, tokenIndex = position63, tokenIndex63
					{
						position72 := position
						{
							position73 := position
							if buffer[position] != rune('"') {
								goto l61
							}
							position++
						l74:
							{
								position75, tokenIndex75 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l75
								}
								goto l74
							l75:
								position, tokenIndex = position75, tokenIndex75
							}
							if buffer[position] != rune('"') {
								goto l61
							}
							position++
							add(rulePegText, position73)
						}
						{
							add(ruleAction5, position)
						}
						add(rulequotedKey, position72)
					}
				}
			l63:
				add(rulekey, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 8 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action4)> */
		nil,
		/* 9 quotedKey <- <(<('"' basicChar* '"')> Action5)> */
		nil,
		/* 10 val <- <((<datetime> Action6) / (<float> Action7) / ((&('{') inlineTable) | (&('[') (<array> Action11)) | (&('f' | 't') (<boolean> Action10)) | (&('"' | '\'') (<string> Action9)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action8))))> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					{
						position83 := position
						{
							position84 := position
							{
								position85, tokenIndex85 := position, tokenIndex
								{
									position87 := position
									{
										position88 := position
										{
											position89 := position
											if !_rules[ruledigitDual]() {
												goto l86
											}
											if !_rules[ruledigitDual]() {
												goto l86
											}
											add(ruledigitQuad, position89)
										}
										add(ruledateFullYear, position88)
									}
									if buffer[position] != rune('-') {
										goto l86
									}
									position++
									{
										position90 := position
										if !_rules[ruledigitDual]() {
											goto l86
										}
										add(ruledateMonth, position90)
									}
									if buffer[position] != rune('-') {
										goto l86
									}
									position++
									{
										position91 := position
										if !_rules[ruledigitDual]() {
											goto l86
										}
										add(ruledateMDay, position91)
									}
									add(rulefullDate, position87)
								}
								{
									position92, tokenIndex92 := position, tokenIndex
									{
										position94, tokenIndex94 := position, tokenIndex
										if buffer[position] != rune('T') {
											goto l95
										}
										position++
										goto l94
									l95:
										position, tokenIndex = position94, tokenIndex94
										if buffer[position] != rune(' ') {
											goto l92
										}
										position++
									}
								l94:
									{
										position96 := position
										if !_rules[rulepartialTime]() {
											goto l92
										}
										{
											position97, tokenIndex97 := position, tokenIndex
											{
												position99 := position
												{
													position100, tokenIndex100 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l101
													}
													position++
													goto l100
												l101:
													position, tokenIndex = position100, tokenIndex100
													{
														position102 := position
														{
															position103, tokenIndex103 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l104
															}
															position++
															goto l103
														l104:
															position, tokenIndex = position103, tokenIndex103
															if buffer[position] != rune('+') {
																goto l97
															}
															position++
														}
													l103:
														if !_rules[ruletimeHour]() {
															goto l97
														}
														if buffer[position] != rune(':') {
															goto l97
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l97
														}
														add(ruletimeNumoffset, position102)
													}
												}
											l100:
												add(ruletimeOffset, position99)
											}
											goto l98
										l97:
											position, tokenIndex = position97, tokenIndex97
										}
									l98:
										add(rulefullTime, position96)
									}
									goto l93
								l92:
									position, tokenIndex = position92, tokenIndex92
								}
							l93:
								goto l85
							l86:
								position, tokenIndex = position85, tokenIndex85
								if !_rules[rulepartialTime]() {
									goto l82
								}
							}
						l85:
							add(ruledatetime, position84)
						}
						add(rulePegText, position83)
					}
					{
						add(ruleAction6, position)
					}
					goto l81
				l82:
					position, tokenIndex = position81, tokenIndex81
					{
						position107 := position
						{
							position108 := position
							{
								position109, tokenIndex109 := position, tokenIndex
								{
									position111, tokenIndex111 := position, tokenIndex
									if buffer[position] != rune('+') {
										goto l112
									}
									position++
									goto l111
								l112:
									position, tokenIndex = position111, tokenIndex111
									if buffer[position] != rune('-') {
										goto l109
									}
									position++
								}
							l111:
								goto l110
							l109:
								position, tokenIndex = position109, tokenIndex109
							}
						l110:
							{
								switch buffer[position] {
								case 'i':
									if buffer[position] != rune('i') {
										goto l106
									}
									position++
									if buffer[position] != rune('n') {
										goto l106
									}
									position++
									if buffer[position] != rune('f') {
										goto l106
									}
									position++
								case 'n':
									if buffer[position] != rune('n') {
										goto l106
									}
									position++
									if buffer[position] != rune('a') {
										goto l106
									}
									position++
									if buffer[position] != rune('n') {
										goto l106
									}
									position++
								default:
									{
										position114 := position
										if !_rules[ruledecimalInt]() {
											goto l106
										}
										{
											position115, tokenIndex115 := position, tokenIndex
											if !_rules[rulefloatFrac]() {
												goto l116
											}
											{
												position117, tokenIndex117 := position, tokenIndex
												if !_rules[rulefloatExp]() {
													goto l117
												}
												goto l118
											l117:
												position, tokenIndex = position117, tokenIndex117
											}
										l118:
											goto l115
										l116:
											position, tokenIndex = position115, tokenIndex115
											{
												position119, tokenIndex119 := position, tokenIndex
												if !_rules[rulefloatFrac]() {
													goto l119
												}
												goto l120
											l119:
												position, tokenIndex = position119, tokenIndex119
											}
										l120:
											if !_rules[rulefloatExp]() {
												goto l106
											}
										}
									l115:
										add(rulefloatDigits, position114)
									}
								}
							}

							add(rulefloat, position108)
						}
						add(rulePegText, position107)
					}
					{
						add(ruleAction7, position)
					}
					goto l81
				l106:
					position, tokenIndex = position81, tokenIndex81
					{
						switch buffer[position] {
						case '{':
							{
								position123 := position
								if buffer[position] != rune('{') {
									goto l79
								}
								position++
								{
									add(ruleAction14, position)
								}
								if !_rules[rulews]() {
									goto l79
								}
								{
									position125 := position
								l126:
									{
										position127, tokenIndex127 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l127
										}
										{
											position128, tokenIndex128 := position, tokenIndex
											{
												position130 := position
												if !_rules[rulews]() {
													goto l128
												}
												if buffer[position] != rune(',') {
													goto l128
												}
												position++
												if !_rules[rulews]() {
													goto l128
												}
												add(ruleinlineTableValSep, position130)
											}
											goto l129
										l128:
											position, tokenIndex = position128, tokenIndex128
										}
									l129:
										goto l126
									l127:
										position, tokenIndex = position127, tokenIndex127
									}
									add(ruleinlineTableKeyValues, position125)
								}
								if !_rules[rulews]() {
									goto l79
								}
								if buffer[position] != rune('}') {
									goto l79
								}
								position++
								{
									add(ruleAction15, position)
								}
								add(ruleinlineTable, position123)
							}
						case '[':
							{
								position132 := position
								{
									position133 := position
									if buffer[position] != rune('[') {
										goto l79
									}
									position++
									{
										add(ruleAction23, position)
									}
									if !_rules[rulewsnl]() {
										goto l79
									}
									{
										position135, tokenIndex135 := position, tokenIndex
										{
											position137 := position
											if !_rules[ruleval]() {
												goto l135
											}
											{
												add(ruleAction24, position)
											}
										l139:
											{
												position140, tokenIndex140 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l140
												}
												{
													position141, tokenIndex141 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l141
													}
													goto l142
												l141:
													position, tokenIndex = position141, tokenIndex141
												}
											l142:
												if !_rules[rulewsnl]() {
													goto l140
												}
												if !_rules[rulearraySep]() {
													goto l140
												}
												if !_rules[rulewsnl]() {
													goto l140
												}
												{
													position143, tokenIndex143 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l143
													}
													goto l144
												l143:
													position, tokenIndex = position143, tokenIndex143
												}
											l144:
												if !_rules[rulewsnl]() {
													goto l140
												}
												if !_rules[ruleval]() {
													goto l140
												}
												{
													add(ruleAction25, position)
												}
												goto l139
											l140:
												position, tokenIndex = position140, tokenIndex140
											}
											if !_rules[rulewsnl]() {
												goto l135
											}
											{
												position146, tokenIndex146 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l146
												}
												goto l147
											l146:
												position, tokenIndex = position146, tokenIndex146
											}
										l147:
											if !_rules[rulewsnl]() {
												goto l135
											}
											{
												position148, tokenIndex148 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l148
												}
												goto l149
											l148:
												position, tokenIndex = position148, tokenIndex148
											}
										l149:
											add(rulearrayValues, position137)
										}
										goto l136
									l135:
										position, tokenIndex = position135, tokenIndex135
									}
								l136:
									if !_rules[rulewsnl]() {
										goto l79
									}
									if buffer[position] != rune(']') {
										goto l79
									}
									position++
									add(rulearray, position133)
								}
								add(rulePegText, position132)
							}
							{
								add(ruleAction11, position)
							}
						case 'f', 't':
							{
								position151 := position
								{
									position152 := position
									{
										position153, tokenIndex153 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l154
										}
										position++
										if buffer[position] != rune('r') {
											goto l154
										}
										position++
										if buffer[position] != rune('u') {
											goto l154
										}
										position++
										if buffer[position] != rune('e') {
											goto l154
										}
										position++
										goto l153
									l154:
										position, tokenIndex = position153, tokenIndex153
										if buffer[position] != rune('f') {
											goto l79
										}
										position++
										if buffer[position] != rune('a') {
											goto l79
										}
										position++
										if buffer[position] != rune('l') {
											goto l79
										}
										position++
										if buffer[position] != rune('s') {
											goto l79
										}
										position++
										if buffer[position] != rune('e') {
											goto l79
										}
										position++
									}
								l153:
									add(ruleboolean, position152)
								}
								add(rulePegText, position151)
							}
							{
								add(ruleAction10, position)
							}
						case '"', '\'':
							{
								position156 := position
								{
									position157 := position
									{
										position158, tokenIndex158 := position, tokenIndex
										{
											position160 := position
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											{
												position161 := position
												{
													position162 := position
												l163:
													{
														position164, tokenIndex164 := position, tokenIndex
														{
															position165, tokenIndex165 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l165
															}
															position++
															if buffer[position] != rune('\'') {
																goto l165
															}
															position++
															if buffer[position] != rune('\'') {
																goto l165
															}
															position++
															goto l164
														l165:
															position, tokenIndex = position165, tokenIndex165
														}
														{
															position166, tokenIndex166 := position, tokenIndex
															{
																position168 := position
																{
																	position169, tokenIndex169 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l170
																	}
																	position++
																	goto l169
																l170:
																	position, tokenIndex = position169, tokenIndex169
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l167
																	}
																	position++
																}
															l169:
																add(rulemlLiteralChar, position168)
															}
															goto l166
														l167:
															position, tokenIndex = position166, tokenIndex166
															if !_rules[rulenewline]() {
																goto l164
															}
														}
													l166:
														goto l163
													l164:
														position, tokenIndex = position164, tokenIndex164
													}
													add(rulemlLiteralBody, position162)
												}
												add(rulePegText, position161)
											}
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											if buffer[position] != rune('\'') {
												goto l159
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(rulemlLiteralString, position160)
										}
										goto l158
									l159:
										position, tokenIndex = position158, tokenIndex158
										{
											position173 := position
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											{
												position174 := position
											l175:
												{
													position176, tokenIndex176 := position, tokenIndex
													{
														position177 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l176
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l176
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l176
																}
																position++
															}
														}

														add(ruleliteralChar, position177)
													}
													goto l175
												l176:
													position, tokenIndex = position176, tokenIndex176
												}
												add(rulePegText, position174)
											}
											if buffer[position] != rune('\'') {
												goto l172
											}
											position++
											{
												add(ruleAction21, position)
											}
											add(ruleliteralString, position173)
										}
										goto l158
									l172:
										position, tokenIndex = position158, tokenIndex158
										{
											position181 := position
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											{
												position182 := position
											l183:
												{
													position184, tokenIndex184 := position, tokenIndex
													{
														position185, tokenIndex185 := position, tokenIndex
														{
															position187, tokenIndex187 := position, tokenIndex
															if buffer[position] != rune('"') {
																goto l187
															}
															position++
															if buffer[position] != rune('"') {
																goto l187
															}
															position++
															if buffer[position] != rune('"') {
																goto l187
															}
															position++
															goto l186
														l187:
															position, tokenIndex = position187, tokenIndex187
														}
														if buffer[position] != rune('"') {
															goto l186
														}
														position++
														{
															add(ruleAction19, position)
														}
														goto l185
													l186:
														position, tokenIndex = position185, tokenIndex185
														{
															position190 := position
															{
																position191, tokenIndex191 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l192
																}
																goto l191
															l192:
																position, tokenIndex = position191, tokenIndex191
																if !_rules[rulenewline]() {
																	goto l189
																}
															}
														l191:
															add(rulePegText, position190)
														}
														{
															add(ruleAction20, position)
														}
														goto l185
													l189:
														position, tokenIndex = position185, tokenIndex185
														if !_rules[ruleescape]() {
															goto l184
														}
														if !_rules[rulenewline]() {
															goto l184
														}
														if !_rules[rulewsnl]() {
															goto l184
														}
													}
												l185:
													goto l183
												l184:
													position, tokenIndex = position184, tokenIndex184
												}
												add(rulemlBasicBody, position182)
											}
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											if buffer[position] != rune('"') {
												goto l180
											}
											position++
											{
												add(ruleAction18, position)
											}
											add(rulemlBasicString, position181)
										}
										goto l158
									l180:
										position, tokenIndex = position158, tokenIndex158
										{
											position195 := position
											{
												position196 := position
												if buffer[position] != rune('"') {
													goto l79
												}
												position++
											l197:
												{
													position198, tokenIndex198 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l198
													}
													goto l197
												l198:
													position, tokenIndex = position198, tokenIndex198
												}
												if buffer[position] != rune('"') {
													goto l79
												}
												position++
												add(rulePegText, position196)
											}
											{
												add(ruleAction17, position)
											}
											add(rulebasicString, position195)
										}
									}
								l158:
									add(rulestring, position157)
								}
								add(rulePegText, position156)
							}
							{
								add(ruleAction9, position)
							}
						default:
							{
								position201 := position
								{
									position202 := position
									{
										switch buffer[position] {
										case '-':
											if buffer[position] != rune('-') {
												goto l79
											}
											position++
											if !_rules[ruleanyInt]() {
												goto l79
											}
										case '+':
											if buffer[position] != rune('+') {
												goto l79
											}
											position++
											if !_rules[ruledecimalInt]() {
												goto l79
											}
										default:
											if !_rules[ruleanyInt]() {
												goto l79
											}
										}
									}

									add(ruleinteger, position202)
								}
								add(rulePegText, position201)
							}
							{
								add(ruleAction8, position)
							}
						}
					}

				}
			l81:
				add(ruleval, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 11 table <- <(stdTable / arrayTable)> */
		nil,
		/* 12 stdTable <- <('[' ws <tableKey> ws ']' Action12)> */
		nil,
		/* 13 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action13)> */
		nil,
		/* 14 inlineTable <- <('{' Action14 ws inlineTableKeyValues ws '}' Action15)> */
		nil,
		/* 15 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 16 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position210, tokenIndex210 := position, tokenIndex
			{
				position211 := position
				if !_rules[ruletableKeyComp]() {
					goto l210
				}
			l212:
				{
					position213, tokenIndex213 := position, tokenIndex
					{
						position214 := position
						if !_rules[rulews]() {
							goto l213
						}
						if buffer[position] != rune('.') {
							goto l213
						}
						position++
						if !_rules[rulews]() {
							goto l213
						}
						add(ruletableKeySep, position214)
					}
					if !_rules[ruletableKeyComp]() {
						goto l213
					}
					goto l212
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
				add(ruletableKey, position211)
			}
			return true
		l210:
			position, tokenIndex = position210, tokenIndex210
			return false
		},
		/* 17 tableKeyComp <- <(key Action16)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if !_rules[rulekey]() {
					goto l215
				}
				{
					add(ruleAction16, position)
				}
				add(ruletableKeyComp, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 18 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 19 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 20 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 21 integer <- <((&('-') ('-' anyInt)) | (&('+') ('+' decimalInt)) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') anyInt))> */
		nil,
		/* 22 anyInt <- <(hexInt / octalInt / binaryInt / decimalInt)> */
		func() bool {
			position222, tokenIndex222 := position, tokenIndex
			{
				position223 := position
				{
					position224, tokenIndex224 := position, tokenIndex
					{
						position226 := position
						if buffer[position] != rune('0') {
							goto l225
						}
						position++
						if buffer[position] != rune('x') {
							goto l225
						}
						position++
						if !_rules[rulehexDigit]() {
							goto l225
						}
					l227:
						{
							position228, tokenIndex228 := position, tokenIndex
							{
								position229, tokenIndex229 := position, tokenIndex
								if !_rules[rulehexDigit]() {
									goto l230
								}
								goto l229
							l230:
								position, tokenIndex = position229, tokenIndex229
								if buffer[position] != rune('_') {
									goto l228
								}
								position++
								if !_rules[rulehexDigit]() {
									goto l228
								}
							}
						l229:
							goto l227
						l228:
							position, tokenIndex = position228, tokenIndex228
						}
						add(rulehexInt, position226)
					}
					goto l224
				l225:
					position, tokenIndex = position224, tokenIndex224
					{
						position232 := position
						if buffer[position] != rune('0') {
							goto l231
						}
						position++
						if buffer[position] != rune('o') {
							goto l231
						}
						position++
						if !_rules[ruleoctalDigit]() {
							goto l231
						}
					l233:
						{
							position234, tokenIndex234 := position, tokenIndex
							{
								position235, tokenIndex235 := position, tokenIndex
								if !_rules[ruleoctalDigit]() {
									goto l236
								}
								goto l235
							l236:
								position, tokenIndex = position235, tokenIndex235
								if buffer[position] != rune('_') {
									goto l234
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l234
								}
							}
						l235:
							goto l233
						l234:
							position, tokenIndex = position234, tokenIndex234
						}
						add(ruleoctalInt, position232)
					}
					goto l224
				l231:
					position, tokenIndex = position224, tokenIndex224
					{
						position238 := position
						if buffer[position] != rune('0') {
							goto l237
						}
						position++
						if buffer[position] != rune('b') {
							goto l237
						}
						position++
						if !_rules[rulebinaryDigit]() {
							goto l237
						}
					l239:
						{
							position240, tokenIndex240 := position, tokenIndex
							{
								position241, tokenIndex241 := position, tokenIndex
								if !_rules[rulebinaryDigit]() {
									goto l242
								}
								goto l241
							l242:
								position, tokenIndex = position241, tokenIndex241
								if buffer[position] != rune('_') {
									goto l240
								}
								position++
								if !_rules[ruleoctalDigit]() {
									goto l240
								}
							}
						l241:
							goto l239
						l240:
							position, tokenIndex = position240, tokenIndex240
						}
						add(rulebinaryInt, position238)
					}
					goto l224
				l237:
					position, tokenIndex = position224, tokenIndex224
					if !_rules[ruledecimalInt]() {
						goto l222
					}
				}
			l224:
				add(ruleanyInt, position223)
			}
			return true
		l222:
			position, tokenIndex = position222, tokenIndex222
			return false
		},
		/* 23 decimalInt <- <(([1-9] (decimalDigit / ('_' decimalDigit))+) / decimalDigit)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if c := buffer[position]; c < rune('1') || c > rune('9') {
						goto l246
					}
					position++
					{
						position249, tokenIndex249 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l250
						}
						goto l249
					l250:
						position, tokenIndex = position249, tokenIndex249
						if buffer[position] != rune('_') {
							goto l246
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l246
						}
					}
				l249:
				l247:
					{
						position248, tokenIndex248 := position, tokenIndex
						{
							position251, tokenIndex251 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l252
							}
							goto l251
						l252:
							position, tokenIndex = position251, tokenIndex251
							if buffer[position] != rune('_') {
								goto l248
							}
							position++
							if !_rules[ruledecimalDigit]() {
								goto l248
							}
						}
					l251:
						goto l247
					l248:
						position, tokenIndex = position248, tokenIndex248
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruledecimalDigit]() {
						goto l243
					}
				}
			l245:
				add(ruledecimalInt, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 24 decimalDigit <- <[0-9]> */
		func() bool {
			position253, tokenIndex253 := position, tokenIndex
			{
				position254 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l253
				}
				position++
				add(ruledecimalDigit, position254)
			}
			return true
		l253:
			position, tokenIndex = position253, tokenIndex253
			return false
		},
		/* 25 hexInt <- <('0' 'x' hexDigit (hexDigit / ('_' hexDigit))*)> */
		nil,
		/* 26 hexDigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l256
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l256
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l256
						}
						position++
					}
				}

				add(rulehexDigit, position257)
			}
			return true
		l256:
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 27 octalInt <- <('0' 'o' octalDigit (octalDigit / ('_' octalDigit))*)> */
		nil,
		/* 28 octalDigit <- <[0-7]> */
		func() bool {
			position260, tokenIndex260 := position, tokenIndex
			{
				position261 := position
				if c := buffer[position]; c < rune('0') || c > rune('7') {
					goto l260
				}
				position++
				add(ruleoctalDigit, position261)
			}
			return true
		l260:
			position, tokenIndex = position260, tokenIndex260
			return false
		},
		/* 29 binaryInt <- <('0' 'b' binaryDigit (binaryDigit / ('_' octalDigit))*)> */
		nil,
		/* 30 binaryDigit <- <('0' / '1')> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				{
					position265, tokenIndex265 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l266
					}
					position++
					goto l265
				l266:
					position, tokenIndex = position265, tokenIndex265
					if buffer[position] != rune('1') {
						goto l263
					}
					position++
				}
			l265:
				add(rulebinaryDigit, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 31 float <- <(('+' / '-')? ((&('i') ('i' 'n' 'f')) | (&('n') ('n' 'a' 'n')) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') floatDigits)))> */
		nil,
		/* 32 floatDigits <- <(decimalInt ((floatFrac floatExp?) / (floatFrac? floatExp)))> */
		nil,
		/* 33 floatFrac <- <('.' decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position269, tokenIndex269 := position, tokenIndex
			{
				position270 := position
				if buffer[position] != rune('.') {
					goto l269
				}
				position++
				if !_rules[ruledecimalDigit]() {
					goto l269
				}
			l271:
				{
					position272, tokenIndex272 := position, tokenIndex
					{
						position273, tokenIndex273 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l274
						}
						goto l273
					l274:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('_') {
							goto l272
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l272
						}
					}
				l273:
					goto l271
				l272:
					position, tokenIndex = position272, tokenIndex272
				}
				add(rulefloatFrac, position270)
			}
			return true
		l269:
			position, tokenIndex = position269, tokenIndex269
			return false
		},
		/* 34 floatExp <- <(('e' / 'E') ('-' / '+')? decimalDigit (decimalDigit / ('_' decimalDigit))*)> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				{
					position277, tokenIndex277 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l278
					}
					position++
					goto l277
				l278:
					position, tokenIndex = position277, tokenIndex277
					if buffer[position] != rune('E') {
						goto l275
					}
					position++
				}
			l277:
				{
					position279, tokenIndex279 := position, tokenIndex
					{
						position281, tokenIndex281 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l282
						}
						position++
						goto l281
					l282:
						position, tokenIndex = position281, tokenIndex281
						if buffer[position] != rune('+') {
							goto l279
						}
						position++
					}
				l281:
					goto l280
				l279:
					position, tokenIndex = position279, tokenIndex279
				}
			l280:
				if !_rules[ruledecimalDigit]() {
					goto l275
				}
			l283:
				{
					position284, tokenIndex284 := position, tokenIndex
					{
						position285, tokenIndex285 := position, tokenIndex
						if !_rules[ruledecimalDigit]() {
							goto l286
						}
						goto l285
					l286:
						position, tokenIndex = position285, tokenIndex285
						if buffer[position] != rune('_') {
							goto l284
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l284
						}
					}
				l285:
					goto l283
				l284:
					position, tokenIndex = position284, tokenIndex284
				}
				add(rulefloatExp, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 35 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 36 escape <- <'\\'> */
		func() bool {
			position288, tokenIndex288 := position, tokenIndex
			{
				position289 := position
				if buffer[position] != rune('\\') {
					goto l288
				}
				position++
				add(ruleescape, position289)
			}
			return true
		l288:
			position, tokenIndex = position288, tokenIndex288
			return false
		},
		/* 37 hexQuad <- <(hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position290, tokenIndex290 := position, tokenIndex
			{
				position291 := position
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				if !_rules[rulehexDigit]() {
					goto l290
				}
				add(rulehexQuad, position291)
			}
			return true
		l290:
			position, tokenIndex = position290, tokenIndex290
			return false
		},
		/* 38 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 39 basicString <- <(<('"' basicChar* '"')> Action17)> */
		nil,
		/* 40 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position294, tokenIndex294 := position, tokenIndex
			{
				position295 := position
				{
					position296, tokenIndex296 := position, tokenIndex
					{
						position298 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l297
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l297
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l297
								}
								position++
							}
						}

						add(rulebasicUnescaped, position298)
					}
					goto l296
				l297:
					position, tokenIndex = position296, tokenIndex296
					{
						position300 := position
						if !_rules[ruleescape]() {
							goto l294
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l294
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l294
								}
								if !_rules[rulehexQuad]() {
									goto l294
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l294
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l294
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l294
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l294
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l294
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l294
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l294
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l294
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l294
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l294
								}
								position++
							}
						}

						add(ruleescaped, position300)
					}
				}
			l296:
				add(rulebasicChar, position295)
			}
			return true
		l294:
			position, tokenIndex = position294, tokenIndex294
			return false
		},
		/* 41 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') []-\U0010ffff]))> */
		nil,
		/* 42 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action18)> */
		nil,
		/* 43 mlBasicBody <- <((!('"' '"' '"') '"' Action19) / (<(basicChar / newline)> Action20) / (escape newline wsnl))*> */
		nil,
		/* 44 literalString <- <('\'' <literalChar*> '\'' Action21)> */
		nil,
		/* 45 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '\u00ad' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '') [(-\U0010ffff]))> */
		nil,
		/* 46 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action22)> */
		nil,
		/* 47 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 48 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 49 dateFullYear <- <digitQuad> */
		nil,
		/* 50 dateMonth <- <digitDual> */
		nil,
		/* 51 dateMDay <- <digitDual> */
		nil,
		/* 52 timeHour <- <digitDual> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if !_rules[ruledigitDual]() {
					goto l313
				}
				add(ruletimeHour, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 53 timeMinute <- <digitDual> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if !_rules[ruledigitDual]() {
					goto l315
				}
				add(ruletimeMinute, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 54 timeSecond <- <digitDual> */
		nil,
		/* 55 timeSecfrac <- <('.' decimalDigit+)> */
		nil,
		/* 56 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 57 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 58 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				if !_rules[ruletimeHour]() {
					goto l321
				}
				if buffer[position] != rune(':') {
					goto l321
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l321
				}
				if buffer[position] != rune(':') {
					goto l321
				}
				position++
				{
					position323 := position
					if !_rules[ruledigitDual]() {
						goto l321
					}
					add(ruletimeSecond, position323)
				}
				{
					position324, tokenIndex324 := position, tokenIndex
					{
						position326 := position
						if buffer[position] != rune('.') {
							goto l324
						}
						position++
						if !_rules[ruledecimalDigit]() {
							goto l324
						}
					l327:
						{
							position328, tokenIndex328 := position, tokenIndex
							if !_rules[ruledecimalDigit]() {
								goto l328
							}
							goto l327
						l328:
							position, tokenIndex = position328, tokenIndex328
						}
						add(ruletimeSecfrac, position326)
					}
					goto l325
				l324:
					position, tokenIndex = position324, tokenIndex324
				}
			l325:
				add(rulepartialTime, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 59 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 60 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 61 datetime <- <((fullDate (('T' / ' ') fullTime)?) / partialTime)> */
		nil,
		/* 62 digitDual <- <(decimalDigit decimalDigit)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if !_rules[ruledecimalDigit]() {
					goto l332
				}
				if !_rules[ruledecimalDigit]() {
					goto l332
				}
				add(ruledigitDual, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 63 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 64 array <- <('[' Action23 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 65 arrayValues <- <(val Action24 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action25)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 66 arraySep <- <','> */
		func() bool {
			position337, tokenIndex337 := position, tokenIndex
			{
				position338 := position
				if buffer[position] != rune(',') {
					goto l337
				}
				position++
				add(rulearraySep, position338)
			}
			return true
		l337:
			position, tokenIndex = position337, tokenIndex337
			return false
		},
		/* 68 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 70 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 71 Action2 <- <{ p.Newline() }> */
		nil,
		/* 72 Action3 <- <{ p.AddKeyValue() }> */
		nil,
		/* 73 Action4 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 74 Action5 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 75 Action6 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 76 Action7 <- <{ p.SetFloat(begin, end) }> */
		nil,
		/* 77 Action8 <- <{ p.SetInteger(begin, end) }> */
		nil,
		/* 78 Action9 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 79 Action10 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 80 Action11 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 81 Action12 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 82 Action13 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 83 Action14 <- <{ p.StartInlineTable() }> */
		nil,
		/* 84 Action15 <- <{ p.EndInlineTable() }> */
		nil,
		/* 85 Action16 <- <{ p.AddTableKey() }> */
		nil,
		/* 86 Action17 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action18 <- <{ p.SetMultilineBasicString() }> */
		nil,
		/* 88 Action19 <- <{ p.AddMultilineBasicQuote() }> */
		nil,
		/* 89 Action20 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 90 Action21 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 91 Action22 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 92 Action23 <- <{ p.StartArray() }> */
		nil,
		/* 93 Action24 <- <{ p.AddArrayVal() }> */
		nil,
		/* 94 Action25 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
